//
//  AutoSyncMacro.swift
//  WeaveDI
//
//  Created by Wonji Suh on 2025.
//

import Foundation
import SwiftSyntax
import SwiftSyntaxMacros
import SwiftSyntaxBuilder
import SwiftCompilerPlugin

// MARK: - Compiler Plugin (Moved to Plugin.swift)

// Note: @main plugin definition moved to Plugin.swift to avoid duplication
// This file only contains macro implementations

// MARK: - @AutoSync Struct Macro

/// @AutoSync ë§¤í¬ë¡œ: TCA DependencyKeyì™€ WeaveDI InjectedKeyë¥¼ ìë™ìœ¼ë¡œ ë™ê¸°í™”í•©ë‹ˆë‹¤.
///
/// ## ì‚¬ìš©ë²•:
/// ```swift
/// @AutoSync
/// struct UserServiceKey: DependencyKey {
///     static let liveValue = UserServiceImpl()
/// }
/// ```
///
/// ## ìƒì„±ë˜ëŠ” ì½”ë“œ:
/// ```swift
/// struct UserServiceKey: DependencyKey, InjectedKey {
///     static let liveValue = UserServiceImpl()
///
///     // Auto-generated InjectedKey conformance
///     static var testValue: UserServiceImpl { liveValue }
///     static var previewValue: UserServiceImpl { liveValue }
///
///     // Auto-generated TCA â†” WeaveDI sync
///     private static let _autoSyncTrigger: Void = {
///         TCASmartSync.autoDetectAndSync(UserServiceKey.self, value: liveValue)
///         return ()
///     }()
/// }
///
/// // Auto-generated InjectedValues extension
/// extension InjectedValues {
///     var userService: UserServiceImpl {
///         get { self[UserServiceKey.self] }
///         set { self[UserServiceKey.self] = newValue }
///     }
/// }
/// ```
public struct AutoSyncStructMacro: MemberMacro, ExtensionMacro {

  public static func expansion(
    of node: AttributeSyntax,
    providingMembersOf declaration: some DeclGroupSyntax,
    in context: some MacroExpansionContext
  ) throws -> [DeclSyntax] {

    // êµ¬ì¡°ì²´ì¸ì§€ í™•ì¸
    guard let structDecl = declaration.as(StructDeclSyntax.self) else {
      throw AutoSyncError.onlyApplicableToStruct
    }

    // DependencyKey conformance í™•ì¸
    let hasDependencyKey = structDecl.inheritanceClause?.inheritedTypes.contains { type in
      type.type.as(IdentifierTypeSyntax.self)?.name.text == "DependencyKey"
    } ?? false

    guard hasDependencyKey else {
      throw AutoSyncError.mustConformToDependencyKey
    }

    // liveValue ë¶„ì„
    guard let liveValueInfo = analyzeLiveValue(from: structDecl) else {
      throw AutoSyncError.cannotInferLiveValueType
    }

    let structName = structDecl.name.text

    // InjectedKey conformanceìš© ë©¤ë²„ë“¤ ìƒì„±
    let testValueDecl: DeclSyntax = """
            static var testValue: \(raw: liveValueInfo.type) { liveValue }
            """

    let previewValueDecl: DeclSyntax = """
            static var previewValue: \(raw: liveValueInfo.type) { liveValue }
            """

    // ìë™ ë™ê¸°í™” ì´ˆê¸°í™” ì½”ë“œ
    let autoSyncInitDecl: DeclSyntax = """
            private static let _autoSyncTrigger: Void = {
                #if canImport(Dependencies)
                TCASmartSync.autoDetectAndSync(\(raw: structName).self, value: liveValue)
                #endif
                return ()
            }()
            """

    return [testValueDecl, previewValueDecl, autoSyncInitDecl]
  }

  public static func expansion(
    of node: AttributeSyntax,
    providingConformancesOf declaration: some DeclGroupSyntax,
    in context: some MacroExpansionContext
  ) throws -> [(TypeSyntax, GenericWhereClauseSyntax?)] {

    // InjectedKey conformance ì¶”ê°€
    return [("InjectedKey", nil)]
  }

  public static func expansion(
    of node: AttributeSyntax,
    attachedTo declaration: some DeclGroupSyntax,
    providingExtensionsOf type: some TypeSyntaxProtocol,
    conformingTo protocols: [TypeSyntax],
    in context: some MacroExpansionContext
  ) throws -> [ExtensionDeclSyntax] {

    guard let structDecl = declaration.as(StructDeclSyntax.self) else {
      return []
    }

    guard let liveValueInfo = analyzeLiveValue(from: structDecl) else {
      return []
    }

    let structName = structDecl.name.text
    let propertyName = generatePropertyName(from: structName)

    // InjectedValues extension ìƒì„±
    let extensionDecl: DeclSyntax = """
            extension InjectedValues {
                /// Auto-generated by @AutoSync for \(raw: structName)
                var \(raw: propertyName): \(raw: liveValueInfo.type) {
                    get { self[\(raw: structName).self] }
                    set { self[\(raw: structName).self] = newValue }
                }
            }
            """

    guard let extensionSyntax = extensionDecl.as(ExtensionDeclSyntax.self) else {
      return []
    }

    return [extensionSyntax]
  }

  // MARK: - Helper Methods

  private static func analyzeLiveValue(from structDecl: StructDeclSyntax) -> LiveValueInfo? {
    for member in structDecl.memberBlock.members {
      if let variableDecl = member.decl.as(VariableDeclSyntax.self) {
        for binding in variableDecl.bindings {
          if let identifier = binding.pattern.as(IdentifierPatternSyntax.self),
             identifier.identifier.text == "liveValue" {

            let type: String
            let expression: ExprSyntax?

            // íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ê²½ìš°
            if let typeAnnotation = binding.typeAnnotation {
              type = typeAnnotation.type.description.trimmingCharacters(in: .whitespaces)
              expression = binding.initializer?.value
            }
            // ì´ˆê¸°í™” í‘œí˜„ì‹ì—ì„œ íƒ€ì… ì¶”ë¡ 
            else if let initializer = binding.initializer {
              if let inferredType = inferTypeFromExpression(initializer.value) {
                type = inferredType
                expression = initializer.value
              } else {
                return nil
              }
            } else {
              return nil
            }

            return LiveValueInfo(type: type, expression: expression)
          }
        }
      }
    }
    return nil
  }

  internal static func inferTypeFromExpression(_ expression: ExprSyntax) -> String? {
    // í•¨ìˆ˜ í˜¸ì¶œ í‘œí˜„ì‹ (ì˜ˆ: UserServiceImpl())
    if let functionCall = expression.as(FunctionCallExprSyntax.self) {
      if let identifier = functionCall.calledExpression.as(DeclReferenceExprSyntax.self) {
        return identifier.baseName.text
      }
    }

    // ë©¤ë²„ ì ‘ê·¼ í‘œí˜„ì‹ (ì˜ˆ: ServiceFactory.shared)
    if let memberAccess = expression.as(MemberAccessExprSyntax.self) {
      if let baseType = memberAccess.base?.description.trimmingCharacters(in: .whitespaces) {
        return baseType
      }
    }

    // ì‹ë³„ì í‘œí˜„ì‹ (ì˜ˆ: sharedInstance)
    if let identifier = expression.as(DeclReferenceExprSyntax.self) {
      return identifier.baseName.text
    }

    return nil
  }

  private static func generatePropertyName(from structName: String) -> String {
    var name = structName

    // "Key" ì ‘ë¯¸ì‚¬ ì œê±°
    if name.hasSuffix("Key") {
      name = String(name.dropLast(3))
    }

    // "DependencyKey" ì ‘ë¯¸ì‚¬ ì œê±°
    if name.hasSuffix("DependencyKey") {
      name = String(name.dropLast(13))
    }

    // ì²« ê¸€ìë¥¼ ì†Œë¬¸ìë¡œ ë³€ê²½
    if !name.isEmpty {
      name = name.prefix(1).lowercased() + name.dropFirst()
    }

    return name
  }
}

// MARK: - @ReverseAutoSync Macro

/// @ReverseAutoSync ë§¤í¬ë¡œ: WeaveDI InjectedKeyë¥¼ TCA DependencyKeyë¡œ ìë™ ë³€í™˜í•©ë‹ˆë‹¤
public struct ReverseAutoSyncMacro: MemberMacro {

  public static func expansion(
    of node: AttributeSyntax,
    providingMembersOf declaration: some DeclGroupSyntax,
    in context: some MacroExpansionContext
  ) throws -> [DeclSyntax] {

    // êµ¬ì¡°ì²´ì¸ì§€ í™•ì¸
    guard let structDecl = declaration.as(StructDeclSyntax.self) else {
      throw AutoSyncError.onlyApplicableToStruct
    }

    // InjectedKey conformance í™•ì¸
    let hasInjectedKey = structDecl.inheritanceClause?.inheritedTypes.contains { type in
      type.type.as(IdentifierTypeSyntax.self)?.name.text == "InjectedKey"
    } ?? false

    guard hasInjectedKey else {
      throw AutoSyncError.mustConformToInjectedKey
    }

    // liveValueì˜ Value íƒ€ì… ì¶”ì¶œ
    guard let valueType = extractValueType(from: structDecl) else {
      throw AutoSyncError.cannotInferValueType
    }

    // DependencyKey conformanceìš© ë©¤ë²„ë“¤ ìƒì„±
    let typeAliasDecl: DeclSyntax = """
            typealias Value = \(raw: valueType)
            """

    // TCA ë™ê¸°í™” ì´ˆê¸°í™” ì½”ë“œ
    let _ = structDecl.name.text
    let tcaSyncDecl: DeclSyntax = """
            private static let _tcaSyncTrigger: Void = {
                #if canImport(Dependencies)
                TCASmartSync.autoDetectWeaveDIRegistration(Value.self, value: liveValue)
                #endif
                return ()
            }()
            """

    return [typeAliasDecl, tcaSyncDecl]
  }

  public static func expansion(
    of node: AttributeSyntax,
    providingConformancesOf declaration: some DeclGroupSyntax,
    in context: some MacroExpansionContext
  ) throws -> [(TypeSyntax, GenericWhereClauseSyntax?)] {

    // DependencyKey conformance ì¶”ê°€
    return [("DependencyKey", nil)]
  }

  /// Value íƒ€ì…ì„ ì¶”ì¶œí•©ë‹ˆë‹¤
  private static func extractValueType(from structDecl: StructDeclSyntax) -> String? {
    // liveValueì˜ ë¦¬í„´ íƒ€ì…ì—ì„œ ì¶”ì¶œ
    for member in structDecl.memberBlock.members {
      if let variableDecl = member.decl.as(VariableDeclSyntax.self) {
        for binding in variableDecl.bindings {
          if let identifier = binding.pattern.as(IdentifierPatternSyntax.self),
             identifier.identifier.text == "liveValue" {

            // íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ê²½ìš°
            if let typeAnnotation = binding.typeAnnotation {
              return typeAnnotation.type.description.trimmingCharacters(in: .whitespaces)
            }

            // ì´ˆê¸°í™” í‘œí˜„ì‹ì—ì„œ íƒ€ì… ì¶”ë¡ 
            if let initializer = binding.initializer {
              return AutoSyncStructMacro.inferTypeFromExpression(initializer.value)
            }
          }
        }
      }
    }
    return nil
  }
}

// MARK: - @Component Macro

/// @Component ë§¤í¬ë¡œ: ì˜ì¡´ì„± ì»´í¬ë„ŒíŠ¸ë¥¼ ìë™ ìƒì„±í•˜ê³  @Injectedì™€ ì™„ë²½ í†µí•©
///
/// ## ìƒì„±ë˜ëŠ” ì½”ë“œ:
/// 1. ComponentProtocol conformance
/// 2. registerAll ë©”ì„œë“œ
/// 3. ê° @Provideì— ëŒ€í•œ InjectedKey
/// 4. InjectedValues extension (KeyPath ì§€ì›)
/// 5. ìë™ ë“±ë¡ ì‹œìŠ¤í…œ
public struct ComponentMacro: MemberMacro, ExtensionMacro {

  public static func expansion(
    of node: AttributeSyntax,
    providingMembersOf declaration: some DeclGroupSyntax,
    in context: some MacroExpansionContext
  ) throws -> [DeclSyntax] {

    guard let structDecl = declaration.as(StructDeclSyntax.self) else {
      throw ComponentMacroError.onlyApplicableToStruct
    }

    let structName = structDecl.name.text

    // @Provideë¡œ í‘œì‹œëœ í”„ë¡œí¼í‹°ë“¤ì„ ì°¾ìŠµë‹ˆë‹¤
    let provideProperties = findProvideProperties(in: structDecl)

    var generatedMembers: [DeclSyntax] = []

    // 1. ê° @Provideì— ëŒ€í•œ InjectedKey ìƒì„±
    for property in provideProperties {
      let injectedKey = generateInjectedKey(for: property)
      generatedMembers.append(injectedKey)
    }

    // 2. registerAll ë©”ì„œë“œ ìƒì„± (DIContainer + InjectedValues í†µí•©)
    let registerAllMethod = generateEnhancedRegisterAllMethod(for: provideProperties, structName: structName)
    generatedMembers.append(registerAllMethod)

    // 3. @Injected ìë™ ë“±ë¡ ë©”ì„œë“œ
    let autoRegisterMethod = generateAutoRegisterMethod(for: provideProperties, structName: structName)
    generatedMembers.append(autoRegisterMethod)

    if let metadataDecl = generateMetadataRegistration(for: provideProperties, structName: structName) {
      generatedMembers.append(metadataDecl)
    }

    return generatedMembers
  }

  public static func expansion(
    of node: AttributeSyntax,
    providingConformancesOf declaration: some DeclGroupSyntax,
    in context: some MacroExpansionContext
  ) throws -> [(TypeSyntax, GenericWhereClauseSyntax?)] {

    return [("ComponentProtocol", nil)]
  }

  public static func expansion(
    of node: AttributeSyntax,
    attachedTo declaration: some DeclGroupSyntax,
    providingExtensionsOf type: some TypeSyntaxProtocol,
    conformingTo protocols: [TypeSyntax],
    in context: some MacroExpansionContext
  ) throws -> [ExtensionDeclSyntax] {

    guard let structDecl = declaration.as(StructDeclSyntax.self) else {
      return []
    }

    let provideProperties = findProvideProperties(in: structDecl)
    guard !provideProperties.isEmpty else { return [] }

    // InjectedValues extension ìƒì„±
    let injectedValuesExtension = generateInjectedValuesExtension(for: provideProperties)

    guard let extensionSyntax = injectedValuesExtension.as(ExtensionDeclSyntax.self) else {
      return []
    }

    return [extensionSyntax]
  }

  // MARK: - Helper Methods

  private static func findProvideProperties(in structDecl: StructDeclSyntax) -> [ProvideProperty] {
    var properties: [ProvideProperty] = []

    for member in structDecl.memberBlock.members {
      if let variableDecl = member.decl.as(VariableDeclSyntax.self) {
        for binding in variableDecl.bindings {
          if let identifier = binding.pattern.as(IdentifierPatternSyntax.self) {
            // @Provide ì†ì„±ì´ ìˆëŠ”ì§€ í™•ì¸
            let hasProvideAttribute = variableDecl.attributes.contains { attr in
              if case .attribute(let attributeSyntax) = attr,
                 let identifierType = attributeSyntax.attributeName.as(IdentifierTypeSyntax.self) {
                return identifierType.name.text == "Provide"
              }
              return false
            }

            if hasProvideAttribute {
              let propertyName = identifier.identifier.text
              let propertyType = extractPropertyType(from: binding)
              let scope = extractScope(from: variableDecl.attributes)

              properties.append(ProvideProperty(
                name: propertyName,
                type: propertyType,
                scope: scope,
                componentName: nil // ë§¤í¬ë¡œ ì»¨í…ìŠ¤íŠ¸ì—ì„œëŠ” êµ¬ì¡°ì²´ ì´ë¦„ì„ ì•Œ ìˆ˜ ìˆìŒ
              ))
            }
          }
        }
      }
    }

    return properties
  }

  private static func extractPropertyType(from binding: PatternBindingSyntax) -> String {
    // íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ê²½ìš°
    if let typeAnnotation = binding.typeAnnotation {
      return typeAnnotation.type.description.trimmingCharacters(in: .whitespaces)
    }

    // getterì—ì„œ íƒ€ì… ì¶”ë¡ 
    if let accessorBlock = binding.accessorBlock,
       case .getter = accessorBlock.accessors {
      // ê°„ë‹¨í•œ íƒ€ì… ì¶”ë¡  (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ë¡œì§ í•„ìš”)
      return "Any"
    }

    return "Any"
  }

  private static func extractScope(from attributes: AttributeListSyntax) -> String {
    for attr in attributes {
      if case .attribute(let attributeSyntax) = attr,
         let identifierType = attributeSyntax.attributeName.as(IdentifierTypeSyntax.self),
         identifierType.name.text == "Provide" {

        // @Provideì˜ scope íŒŒë¼ë¯¸í„° ì¶”ì¶œ
        if let argumentList = attributeSyntax.arguments?.as(LabeledExprListSyntax.self) {
          for argument in argumentList {
            if argument.label?.text == "scope" {
              if let memberAccess = argument.expression.as(MemberAccessExprSyntax.self) {
                return memberAccess.declName.baseName.text
              }
            }
          }
        }
      }
    }
    return "transient" // ê¸°ë³¸ê°’
  }

  /// ê°œë³„ @Provideì— ëŒ€í•œ InjectedKey ìƒì„±
  private static func generateInjectedKey(for property: ProvideProperty) -> DeclSyntax {
    let keyName = "\(property.name.prefix(1).uppercased())\(property.name.dropFirst())Key"

    let keyDecl: DeclSyntax = """
            /// Auto-generated InjectedKey for @Provide \(raw: property.name)
            struct \(raw: keyName): InjectedKey {
                typealias Value = \(raw: property.type)
            
                static var liveValue: \(raw: property.type) {
                    let component = \(raw: property.componentName ?? "Self")()
                    return component.\(raw: property.name)
                }
            
                static var testValue: \(raw: property.type) {
                    return liveValue
                }
            
                static var previewValue: \(raw: property.type) {
                    return liveValue
                }
            }
            """

    return keyDecl
  }

  /// ê°•í™”ëœ registerAll ë©”ì„œë“œ (DIContainer + InjectedValues í†µí•©)
  private static func generateEnhancedRegisterAllMethod(for properties: [ProvideProperty], structName: String) -> DeclSyntax {
    var registrationStatements: [String] = []

    for property in properties {
      let scopeText = property.scope == "singleton" ? ".singleton" : ".transient"
      registrationStatements.append("""
                // DIContainer ë“±ë¡
                container.register(\(property.type).self, scope: \(scopeText)) { component.\(property.name) }
                """)
    }

    let registrationBody = registrationStatements.joined(separator: "\n        ")

    let methodDecl: DeclSyntax = """
            static func registerAll(into container: DIContainer) {
                let component = \(raw: structName)()
                \(raw: registrationBody)
            
                // @Injected ìë™ ë“±ë¡ë„ í•¨ê»˜ ìˆ˜í–‰
                Self.autoRegisterToInjectedValues()
            }
            """

    return methodDecl
  }

  private static func generateMetadataRegistration(for properties: [ProvideProperty], structName: String) -> DeclSyntax? {
    guard !properties.isEmpty else { return nil }

    let providedTypesLiteral = properties.map { "\"\($0.type)\"" }.joined(separator: ", ")
    let propertyNamesLiteral = properties.map { "\"\($0.name)\"" }.joined(separator: ", ")
    let scopesLiteral = properties.map { "\"\($0.scope)\"" }.joined(separator: ", ")
    let componentNameLiteral = "\"\(structName)\""

    let decl: DeclSyntax = """
            @discardableResult
            static let __componentMetadata: ComponentMetadata = {
                let metadata = ComponentMetadata(
                    componentName: \(raw: componentNameLiteral),
                    providedTypes: [\(raw: providedTypesLiteral)],
                    propertyNames: [\(raw: propertyNamesLiteral)],
                    scopes: [\(raw: scopesLiteral)]
                )
                ComponentMetadataRegistry.register(metadata)
                return metadata
            }()
            """

    return decl
  }

  /// @Injected ìë™ ë“±ë¡ ë©”ì„œë“œ
  private static func generateAutoRegisterMethod(for properties: [ProvideProperty], structName: String) -> DeclSyntax {
    var autoRegistrationStatements: [String] = []

    for property in properties {
      let keyName = "\(property.name.prefix(1).uppercased())\(property.name.dropFirst())Key"
      autoRegistrationStatements.append("""
                // \(property.name) â†’ @Injected ìë™ ë“±ë¡
                Task.detached {
                    await InjectedValuesAutoRegistrar.shared.registerValue(
                        \(keyName).liveValue,
                        for: \(property.type).self
                    )
                }
                """)
    }

    let autoRegistrationBody = autoRegistrationStatements.joined(separator: "\n        ")

    let methodDecl: DeclSyntax = """
            /// @Provide â†’ @Injected ìë™ ì—°ë™
            static func autoRegisterToInjectedValues() {
                \(raw: autoRegistrationBody)
            
                print("ğŸ”— [\(raw: structName)] ëª¨ë“  @Provide â†’ @Injected ìë™ ë“±ë¡ ì™„ë£Œ")
            }
            """

    return methodDecl
  }

  /// InjectedValues extension ìë™ ìƒì„±
  private static func generateInjectedValuesExtension(for properties: [ProvideProperty]) -> DeclSyntax {
    var extensionMembers: [String] = []

    for property in properties {
      let keyName = "\(property.name.prefix(1).uppercased())\(property.name.dropFirst())Key"

      extensionMembers.append("""
                /// Auto-generated KeyPath for @Provide \(property.name)
                var \(property.name): \(property.type) {
                    get { self[\(keyName).self] }
                    set { self[\(keyName).self] = newValue }
                }
                """)
    }

    let extensionBody = extensionMembers.joined(separator: "\n\n    ")

    let extensionDecl: DeclSyntax = """
            /// Auto-generated InjectedValues extension for @Component
            extension InjectedValues {
                \(raw: extensionBody)
            }
            """

    return extensionDecl
  }

  private static func generateRegisterAllMethod(for properties: [ProvideProperty], structName: String) -> DeclSyntax {
    var registrationStatements: [String] = []

    for property in properties {
      let scopeText = property.scope == "singleton" ? ".singleton" : ".transient"
      registrationStatements.append("""
                container.register(\(property.type).self, scope: \(scopeText)) { component.\(property.name) }
                """)
    }

    let registrationBody = registrationStatements.joined(separator: "\n        ")

    let methodDecl: DeclSyntax = """
            static func registerAll(into container: DIContainer) {
                let component = \(raw: structName)()
                \(raw: registrationBody)
            }
            """

    return methodDecl
  }
}

// MARK: - @Provide Macro

/// @Provide ë§¤í¬ë¡œ: ì»´í¬ë„ŒíŠ¸ ë‚´ì—ì„œ ì œê³µí•  ì˜ì¡´ì„±ì„ í‘œì‹œí•©ë‹ˆë‹¤
public struct ProvideMacro: AccessorMacro {

  public static func expansion(
    of node: AttributeSyntax,
    providingAccessorsOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
  ) throws -> [AccessorDeclSyntax] {

    // @ProvideëŠ” ë‹¨ìˆœí•œ ë§ˆí‚¹ ì—­í• ì´ë¯€ë¡œ ì¶”ê°€ ì ‘ê·¼ì ìƒì„±í•˜ì§€ ì•ŠìŒ
    return []
  }
}

// MARK: - Supporting Types

struct LiveValueInfo {
  let type: String
  let expression: ExprSyntax?
}

struct ProvideProperty {
  let name: String
  let type: String
  let scope: String
  let componentName: String?

  init(name: String, type: String, scope: String, componentName: String? = nil) {
    self.name = name
    self.type = type
    self.scope = scope
    self.componentName = componentName
  }
}

// MARK: - Errors

enum AutoSyncError: Error, CustomStringConvertible {
  case onlyApplicableToStruct
  case mustConformToDependencyKey
  case mustConformToInjectedKey
  case cannotInferLiveValueType
  case cannotInferValueType

  var description: String {
    switch self {
      case .onlyApplicableToStruct:
        return "@AutoSync can only be applied to structs"
      case .mustConformToDependencyKey:
        return "@AutoSync requires the struct to conform to DependencyKey"
      case .mustConformToInjectedKey:
        return "@ReverseAutoSync requires the struct to conform to InjectedKey"
      case .cannotInferLiveValueType:
        return "Cannot infer the type of liveValue. Please add explicit type annotation."
      case .cannotInferValueType:
        return "Cannot infer the Value type. Please add explicit type annotation."
    }
  }
}

enum ComponentMacroError: Error, CustomStringConvertible {
  case onlyApplicableToStruct
  case onlyApplicableToVariable

  var description: String {
    switch self {
      case .onlyApplicableToStruct:
        return "@Component can only be applied to structs"
      case .onlyApplicableToVariable:
        return "@Provide can only be applied to variables"
    }
  }
}
