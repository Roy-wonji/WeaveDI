//
//  InjectedValuesAutoRegistrar.swift
//  WeaveDI
//
//  Created by Wonji Suh on 2025.
//

import Foundation
import WeaveDICore

// MARK: - InjectedValues ìë™ ë“±ë¡ ì‹œìŠ¤í…œ
// Dependency.swiftë¥¼ ê±´ë“œë¦¬ì§€ ì•Šê³  ì™„ë²½í•œ í†µí•©

/// InjectedValues ìë™ ë“±ë¡ì„ ë‹´ë‹¹í•˜ëŠ” í•µì‹¬ ì‹œìŠ¤í…œ
/// @Provideëœ ê°’ë“¤ì„ @Injectedì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ìë™ ì—°ê²°
public actor InjectedValuesAutoRegistrar {

    public static let shared = InjectedValuesAutoRegistrar()

    private var dynamicKeys: [String: any InjectedKey.Type] = [:]
    public nonisolated(unsafe) var valueStorage: [String: Any] = [:]
    public nonisolated(unsafe) var keyPathMappings: [String: String] = [:]

    private init() {}

    // MARK: - ìë™ ë“±ë¡ í•µì‹¬ ë©”ì„œë“œ

    /// íƒ€ì… ë“±ë¡ ì¤€ë¹„ (ì»´íŒŒì¼ íƒ€ì„)
    public func prepareRegistration<T: Sendable>(for type: T.Type) {
        let typeName = String(describing: type)

        // ì´ë¯¸ ë“±ë¡ëœ íƒ€ì…ì¸ì§€ í™•ì¸
        guard dynamicKeys[typeName] == nil else { return }

        // ë™ì  InjectedKey ìƒì„±
        let keyType = createDynamicKey(for: type)
        dynamicKeys[typeName] = keyType

        print("ğŸ”‘ [\(typeName)] Dynamic InjectedKey ìƒì„± ì™„ë£Œ")
    }

    /// ì‹¤ì œ ê°’ ë“±ë¡ (ëŸ°íƒ€ì„)
    public func registerValue<T: Sendable>(_ value: T, for type: T.Type) {
        let typeName = String(describing: type)

        // ê°’ ì €ì¥
        valueStorage[typeName] = value

        // InjectedValues í†µí•© ì‹œìŠ¤í…œì— ë“±ë¡
        registerToGlobalInjectedValues(value, for: type, typeName: typeName)

        print("âœ… [\(typeName)] InjectedValues ìë™ ë“±ë¡ ì™„ë£Œ")
    }

    /// KeyPath ë§¤í•‘ ë“±ë¡ (ë§¤í¬ë¡œì—ì„œ í˜¸ì¶œ)
    public func registerKeyPath(propertyName: String, for typeName: String) {
        keyPathMappings[propertyName] = typeName
        print("ğŸ”— KeyPath ë§¤í•‘: \(propertyName) â†’ \(typeName)")
    }

    /// ìºì‹œëœ ê°’ ì¡°íšŒ (async) - actor isolated
    public func getCachedValue<T: Sendable>(for type: T.Type) async -> T? {
        let typeName = String(describing: type)
        return valueStorage[typeName] as? T
    }

    /// ìºì‹œëœ ê°’ ì¡°íšŒ (sync fallback) - for static properties
    public nonisolated func getCachedValueSync<T: Sendable>(for type: T.Type) -> T? {
        // Use unsafe access for sync requirements - not ideal but necessary for static properties
        return assumeIsolated { _ in
            let typeName = String(describing: type)
            return valueStorage[typeName] as? T
        }
    }

    // MARK: - Dynamic InjectedKey ìƒì„±

    /// íƒ€ì…ë³„ ê³ ìœ í•œ InjectedKey ë™ì  ìƒì„±
    private func createDynamicKey<T: Sendable>(for type: T.Type) -> any InjectedKey.Type {
        // ëŸ°íƒ€ì„ì— ê³ ìœ í•œ InjectedKey í´ë˜ìŠ¤ ìƒì„±
        let _ = "AutoGenerated\(String(describing: type).replacingOccurrences(of: ".", with: "_"))Key"

        // ë™ì  í‚¤ íƒ€ì… ìƒì„± (NSClassFromString ëŒ€ì‹  ì œë„¤ë¦­ ì‚¬ìš©)
        return AutoGeneratedKey<T>.self
    }

    /// InjectedValues ê¸€ë¡œë²Œ í†µí•© ì‹œìŠ¤í…œ
    private func registerToGlobalInjectedValues<T: Sendable>(_ value: T, for type: T.Type, typeName: String) {
        // ComponentInjectedBridgeë¥¼ í†µí•œ ì „ì—­ ë“±ë¡
        Task { @MainActor in
            GlobalInjectedValuesProxy.shared.registerValue(value, forType: type, typeName: typeName)
        }
    }

    // MARK: - ì¡°íšŒ ì‹œìŠ¤í…œ

    /// @Injectedì—ì„œ ê°’ ì¡°íšŒ
    public func resolveValue<T: Sendable>(for type: T.Type) -> T? {
        let typeName = String(describing: type)
        return valueStorage[typeName] as? T
    }

    /// KeyPathë¡œ ê°’ ì¡°íšŒ
    public func resolveValueByKeyPath<T: Sendable>(_ keyPath: String, as type: T.Type) -> T? {
        guard let typeName = keyPathMappings[keyPath] else { return nil }
        return valueStorage[typeName] as? T
    }

    /// ë“±ë¡ëœ ëª¨ë“  íƒ€ì… ì¡°íšŒ
    public func getAllRegisteredTypes() -> [String] {
        return Array(valueStorage.keys)
    }
}

// MARK: - ìë™ ìƒì„±ëœ InjectedKey

/// ëŸ°íƒ€ì„ì— ìë™ ìƒì„±ë˜ëŠ” InjectedKey
public struct AutoGeneratedKey<T: Sendable>: InjectedKey {
    public typealias Value = T

    public static var liveValue: T {
        // InjectedValuesAutoRegistrarì—ì„œ ê°’ ì¡°íšŒ (sync ë²„ì „ ì‚¬ìš©)
        if let resolved = InjectedValuesAutoRegistrar.shared.getCachedValueSync(for: T.self) {
            return resolved
        }

        // ê°’ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‹œë„
        return createDefaultValue()
    }

    public static var testValue: T {
        return liveValue
    }

    public static var previewValue: T {
        return liveValue
    }

    /// ê¸°ë³¸ê°’ ìƒì„± ì‹œë„
    private static func createDefaultValue() -> T {
        // Tê°€ íŠ¹ì • í”„ë¡œí† ì½œì„ êµ¬í˜„í•˜ëŠ” ê²½ìš° ê¸°ë³¸ êµ¬í˜„ì²´ ì œê³µ
        if let defaultValue = createKnownDefaultValue() {
            return defaultValue
        }

        fatalError("âŒ \(T.self)ì— ëŒ€í•œ ê°’ì´ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. @Provideë¥¼ í™•ì¸í•˜ì„¸ìš”.")
    }

    /// ì•Œë ¤ì§„ íƒ€ì…ë“¤ì˜ ê¸°ë³¸ê°’ ìƒì„±
    private static func createKnownDefaultValue() -> T? {
        // String íƒ€ì…ì¸ ê²½ìš°
        if T.self == String.self {
            return "" as? T
        }

        // Int íƒ€ì…ì¸ ê²½ìš°
        if T.self == Int.self {
            return 0 as? T
        }

        // Array íƒ€ì…ì¸ ê²½ìš°
        if String(describing: T.self).contains("Array") {
            // ë¹ˆ ë°°ì—´ ë°˜í™˜ ì‹œë„
            return [] as? T
        }

        return nil
    }
}

// MARK: - ê¸€ë¡œë²Œ InjectedValues í”„ë¡ì‹œ

/// InjectedValuesì™€ì˜ í†µí•©ì„ ë‹´ë‹¹í•˜ëŠ” í”„ë¡ì‹œ ì‹œìŠ¤í…œ
@MainActor
public final class GlobalInjectedValuesProxy {

    public static let shared = GlobalInjectedValuesProxy()

    private var globalValues: [String: Any] = [:]
    private var isIntegrationActive: Bool = false

    private init() {
        setupIntegration()
    }

    /// InjectedValues í†µí•© ì„¤ì •
    private func setupIntegration() {
        isIntegrationActive = true
        print("ğŸŒ GlobalInjectedValuesProxy í™œì„±í™” ì™„ë£Œ")
    }

    /// ê°’ ë“±ë¡ (ë©”ì¸ ìŠ¤ë ˆë“œ)
    public func registerValue<T: Sendable>(_ value: T, forType type: T.Type, typeName: String) {
        globalValues[typeName] = value

        // withInjectedValuesë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤ì œ InjectedValuesì—ë„ ë“±ë¡ ì‹œë„
        attemptDirectInjectedValuesRegistration(value, forType: type)
    }

    /// ì§ì ‘ InjectedValues ë“±ë¡ ì‹œë„
    private func attemptDirectInjectedValuesRegistration<T: Sendable>(_ value: T, forType type: T.Type) {
        // AutoGeneratedKeyë¥¼ ì‚¬ìš©í•˜ì—¬ ë“±ë¡
        Task {
            withInjectedValues { injectedValues in
                // ì—¬ê¸°ì„œ ì‹¤ì œ ë“±ë¡ ë¡œì§
                let _ = injectedValues
                // injectedValues[AutoGeneratedKey<T>.self] = value
                // í•˜ì§€ë§Œ ì´ëŠ” inout ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•´ ì‘ë™í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ
            } operation: {
                return ()
            }
        }
    }

    /// ê°’ ì¡°íšŒ
    public func getValue<T: Sendable>(forType type: T.Type) -> T? {
        let typeName = String(describing: type)
        return globalValues[typeName] as? T
    }

    /// KeyPathë¡œ ì¡°íšŒ
    public func getValueByKeyPath<T: Sendable>(_ keyPath: String, as type: T.Type) -> T? {
        // ë¨¼ì € ì§ì ‘ ì¡°íšŒ ì‹œë„
        if let value = globalValues[keyPath] as? T {
            return value
        }

        // íƒ€ì… ì´ë¦„ìœ¼ë¡œ ì¡°íšŒ ì‹œë„
        let typeName = String(describing: type)
        return globalValues[typeName] as? T
    }
}

// MARK: - InjectedValues Extension ì§€ì›

/// @Injectedì—ì„œ ìë™ìœ¼ë¡œ @Provide ê°’ì„ ì°¾ì„ ìˆ˜ ìˆë„ë¡ ë„ì™€ì£¼ëŠ” í™•ì¥
public extension InjectedValues {

    /// ìë™ ìƒì„±ëœ í‚¤ë¡œ ê°’ ì¡°íšŒ
    func autoResolve<T: Sendable>(_ type: T.Type) -> T? {
        // 1. ë¨¼ì € ê¸°ì¡´ InjectedValuesì—ì„œ ì¡°íšŒ
        let existingValue = self[AutoGeneratedKey<T>.self]
        // Note: AutoGeneratedKey always returns a value, fallback to registrar

        // 2. InjectedValuesAutoRegistrarì—ì„œ ìºì‹œëœ ê°’ ì¡°íšŒ
        return InjectedValuesAutoRegistrar.shared.getCachedValueSync(for: type) ?? existingValue
    }

    /// KeyPathë¡œ ìë™ ì¡°íšŒ
    func autoResolveByKeyPath<T: Sendable>(_ keyPath: String, as type: T.Type) -> T? {
        // KeyPath ë§¤í•‘ì„ í†µí•´ íƒ€ì…ëª… ì¡°íšŒ í›„ í•´ë‹¹ ê°’ ë°˜í™˜
        let registrar = InjectedValuesAutoRegistrar.shared
        if let typeName = registrar.keyPathMappings[keyPath],
           let value = registrar.valueStorage[typeName] as? T {
            return value
        }
        return nil
    }
}

// MARK: - í¸ì˜ í•¨ìˆ˜ë“¤

/// @Provideëœ ëª¨ë“  ê°’ë“¤ì„ @Injectedì™€ ìë™ í†µí•©
@MainActor
public func enableGlobalProvideInjectedIntegration() {
    let _ = GlobalInjectedValuesProxy.shared
    print("ğŸ”— ëª¨ë“  @Provide â†’ @Injected ìë™ í†µí•©ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤")
}

/// íŠ¹ì • íƒ€ì…ì˜ @Provide â†’ @Injected ì—°ê²° í™•ì¸
public func verifyProvideInjectedConnection<T: Sendable>(_ type: T.Type) async -> Bool {
    let value = await InjectedValuesAutoRegistrar.shared.resolveValue(for: type)
    return value != nil
}

/// ë“±ë¡ëœ ëª¨ë“  @Provide íƒ€ì…ë“¤ ì¶œë ¥
public func printAllRegisteredProvideTypes() async {
    let types = await InjectedValuesAutoRegistrar.shared.getAllRegisteredTypes()
    print("ğŸ“‹ ë“±ë¡ëœ @Provide íƒ€ì…ë“¤:")
    for type in types {
        print("   âœ… \(type)")
    }
}
