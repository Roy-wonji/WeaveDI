//
//  InjectedValuesAutoRegistrar.swift
//  WeaveDI
//
//  Created by Wonji Suh on 2025.
//

import Foundation

// MARK: - InjectedValues 자동 등록 시스템
// Dependency.swift를 건드리지 않고 완벽한 통합

/// InjectedValues 자동 등록을 담당하는 핵심 시스템
/// @Provide된 값들을 @Injected에서 사용할 수 있도록 자동 연결
public actor InjectedValuesAutoRegistrar {

    public static let shared = InjectedValuesAutoRegistrar()

    private var dynamicKeys: [String: any InjectedKey.Type] = [:]
    public nonisolated(unsafe) var valueStorage: [String: Any] = [:]
    public nonisolated(unsafe) var keyPathMappings: [String: String] = [:]

    private init() {}

    // MARK: - 자동 등록 핵심 메서드

    /// 타입 등록 준비 (컴파일 타임)
    public func prepareRegistration<T: Sendable>(for type: T.Type) {
        let typeName = String(describing: type)

        // 이미 등록된 타입인지 확인
        guard dynamicKeys[typeName] == nil else { return }

        // 동적 InjectedKey 생성
        let keyType = createDynamicKey(for: type)
        dynamicKeys[typeName] = keyType

        print("🔑 [\(typeName)] Dynamic InjectedKey 생성 완료")
    }

    /// 실제 값 등록 (런타임)
    public func registerValue<T: Sendable>(_ value: T, for type: T.Type) {
        let typeName = String(describing: type)

        // 값 저장
        valueStorage[typeName] = value

        // InjectedValues 통합 시스템에 등록
        registerToGlobalInjectedValues(value, for: type, typeName: typeName)

        print("✅ [\(typeName)] InjectedValues 자동 등록 완료")
    }

    /// KeyPath 매핑 등록 (매크로에서 호출)
    public func registerKeyPath(propertyName: String, for typeName: String) {
        keyPathMappings[propertyName] = typeName
        print("🔗 KeyPath 매핑: \(propertyName) → \(typeName)")
    }

    /// 캐시된 값 조회 (async) - actor isolated
    public func getCachedValue<T: Sendable>(for type: T.Type) async -> T? {
        let typeName = String(describing: type)
        return valueStorage[typeName] as? T
    }

    /// 캐시된 값 조회 (sync fallback) - for static properties
    public nonisolated func getCachedValueSync<T: Sendable>(for type: T.Type) -> T? {
        // Use unsafe access for sync requirements - not ideal but necessary for static properties
        return assumeIsolated { _ in
            let typeName = String(describing: type)
            return valueStorage[typeName] as? T
        }
    }

    // MARK: - Dynamic InjectedKey 생성

    /// 타입별 고유한 InjectedKey 동적 생성
    private func createDynamicKey<T: Sendable>(for type: T.Type) -> any InjectedKey.Type {
        // 런타임에 고유한 InjectedKey 클래스 생성
        let _ = "AutoGenerated\(String(describing: type).replacingOccurrences(of: ".", with: "_"))Key"

        // 동적 키 타입 생성 (NSClassFromString 대신 제네릭 사용)
        return AutoGeneratedKey<T>.self
    }

    /// InjectedValues 글로벌 통합 시스템
    private func registerToGlobalInjectedValues<T: Sendable>(_ value: T, for type: T.Type, typeName: String) {
        // ComponentInjectedBridge를 통한 전역 등록
        Task { @MainActor in
            GlobalInjectedValuesProxy.shared.registerValue(value, forType: type, typeName: typeName)
        }
    }

    // MARK: - 조회 시스템

    /// @Injected에서 값 조회
    public func resolveValue<T: Sendable>(for type: T.Type) -> T? {
        let typeName = String(describing: type)
        return valueStorage[typeName] as? T
    }

    /// KeyPath로 값 조회
    public func resolveValueByKeyPath<T: Sendable>(_ keyPath: String, as type: T.Type) -> T? {
        guard let typeName = keyPathMappings[keyPath] else { return nil }
        return valueStorage[typeName] as? T
    }

    /// 등록된 모든 타입 조회
    public func getAllRegisteredTypes() -> [String] {
        return Array(valueStorage.keys)
    }
}

// MARK: - 자동 생성된 InjectedKey

/// 런타임에 자동 생성되는 InjectedKey
public struct AutoGeneratedKey<T: Sendable>: InjectedKey {
    public typealias Value = T

    public static var liveValue: T {
        // InjectedValuesAutoRegistrar에서 값 조회 (sync 버전 사용)
        if let resolved = InjectedValuesAutoRegistrar.shared.getCachedValueSync(for: T.self) {
            return resolved
        }

        // 값이 없으면 기본값 시도
        return createDefaultValue()
    }

    public static var testValue: T {
        return liveValue
    }

    public static var previewValue: T {
        return liveValue
    }

    /// 기본값 생성 시도
    private static func createDefaultValue() -> T {
        // T가 특정 프로토콜을 구현하는 경우 기본 구현체 제공
        if let defaultValue = createKnownDefaultValue() {
            return defaultValue
        }

        fatalError("❌ \(T.self)에 대한 값이 등록되지 않았습니다. @Provide를 확인하세요.")
    }

    /// 알려진 타입들의 기본값 생성
    private static func createKnownDefaultValue() -> T? {
        // String 타입인 경우
        if T.self == String.self {
            return "" as? T
        }

        // Int 타입인 경우
        if T.self == Int.self {
            return 0 as? T
        }

        // Array 타입인 경우
        if String(describing: T.self).contains("Array") {
            // 빈 배열 반환 시도
            return [] as? T
        }

        return nil
    }
}

// MARK: - 글로벌 InjectedValues 프록시

/// InjectedValues와의 통합을 담당하는 프록시 시스템
@MainActor
public final class GlobalInjectedValuesProxy {

    public static let shared = GlobalInjectedValuesProxy()

    private var globalValues: [String: Any] = [:]
    private var isIntegrationActive: Bool = false

    private init() {
        setupIntegration()
    }

    /// InjectedValues 통합 설정
    private func setupIntegration() {
        isIntegrationActive = true
        print("🌐 GlobalInjectedValuesProxy 활성화 완료")
    }

    /// 값 등록 (메인 스레드)
    public func registerValue<T: Sendable>(_ value: T, forType type: T.Type, typeName: String) {
        globalValues[typeName] = value

        // withInjectedValues를 사용하여 실제 InjectedValues에도 등록 시도
        attemptDirectInjectedValuesRegistration(value, forType: type)
    }

    /// 직접 InjectedValues 등록 시도
    private func attemptDirectInjectedValuesRegistration<T: Sendable>(_ value: T, forType type: T.Type) {
        // AutoGeneratedKey를 사용하여 등록
        Task {
            withInjectedValues { injectedValues in
                // 여기서 실제 등록 로직
                let _ = injectedValues
                // injectedValues[AutoGeneratedKey<T>.self] = value
                // 하지만 이는 inout 매개변수에 대해 작동하지 않을 수 있음
            } operation: {
                return ()
            }
        }
    }

    /// 값 조회
    public func getValue<T: Sendable>(forType type: T.Type) -> T? {
        let typeName = String(describing: type)
        return globalValues[typeName] as? T
    }

    /// KeyPath로 조회
    public func getValueByKeyPath<T: Sendable>(_ keyPath: String, as type: T.Type) -> T? {
        // 먼저 직접 조회 시도
        if let value = globalValues[keyPath] as? T {
            return value
        }

        // 타입 이름으로 조회 시도
        let typeName = String(describing: type)
        return globalValues[typeName] as? T
    }
}

// MARK: - InjectedValues Extension 지원

/// @Injected에서 자동으로 @Provide 값을 찾을 수 있도록 도와주는 확장
public extension InjectedValues {

    /// 자동 생성된 키로 값 조회
    func autoResolve<T: Sendable>(_ type: T.Type) -> T? {
        // 1. 먼저 기존 InjectedValues에서 조회
        let existingValue = self[AutoGeneratedKey<T>.self]
        // Note: AutoGeneratedKey always returns a value, fallback to registrar

        // 2. InjectedValuesAutoRegistrar에서 캐시된 값 조회
        return InjectedValuesAutoRegistrar.shared.getCachedValueSync(for: type) ?? existingValue
    }

    /// KeyPath로 자동 조회
    func autoResolveByKeyPath<T: Sendable>(_ keyPath: String, as type: T.Type) -> T? {
        // KeyPath 매핑을 통해 타입명 조회 후 해당 값 반환
        let registrar = InjectedValuesAutoRegistrar.shared
        if let typeName = registrar.keyPathMappings[keyPath],
           let value = registrar.valueStorage[typeName] as? T {
            return value
        }
        return nil
    }
}

// MARK: - 편의 함수들

/// @Provide된 모든 값들을 @Injected와 자동 통합
@MainActor
public func enableGlobalProvideInjectedIntegration() {
    let _ = GlobalInjectedValuesProxy.shared
    print("🔗 모든 @Provide → @Injected 자동 통합이 활성화되었습니다")
}

/// 특정 타입의 @Provide → @Injected 연결 확인
public func verifyProvideInjectedConnection<T: Sendable>(_ type: T.Type) async -> Bool {
    let value = await InjectedValuesAutoRegistrar.shared.resolveValue(for: type)
    return value != nil
}

/// 등록된 모든 @Provide 타입들 출력
public func printAllRegisteredProvideTypes() async {
    let types = await InjectedValuesAutoRegistrar.shared.getAllRegisteredTypes()
    print("📋 등록된 @Provide 타입들:")
    for type in types {
        print("   ✅ \(type)")
    }
}