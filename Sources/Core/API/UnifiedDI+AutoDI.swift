import Foundation

// MARK: - Auto DI Features & Diagnostics

public extension UnifiedDI {
  /// 최적화 설정을 간편하게 조정합니다.
  static func configureOptimization(
    debounceMs: Int = 100,
    threshold: Int = 10,
    realTimeUpdate: Bool = true
  ) {
    Task { @DIActor in
      AutoDIOptimizer.shared.updateConfig("threshold: \(threshold), realTime: \(realTimeUpdate)")
      AutoDIOptimizer.shared.setDebounceInterval(ms: debounceMs)
    }
  }

  /// 그래프 변경 히스토리를 가져옵니다.
  static func getGraphChanges(limit: Int = 10) async -> [(timestamp: Date, changes: [String: NodeChangeType])] {
    let deps = Array(AutoDIOptimizer.readSnapshot().dependencies.prefix(limit))
    let now = Date()
    return deps.enumerated().map { index, dep in
      (timestamp: now.addingTimeInterval(-Double(index) * 60),
       changes: [dep.from: NodeChangeType(change: "added dependency to \(dep.to)")])
    }
  }

  /// 자동 생성된 의존성 그래프를 시각화합니다.
  static func autoGraph() -> String {
    DIContainer.shared.getAutoGeneratedGraph()
  }

  /// 자동 최적화된 타입들을 반환합니다.
  static func optimizedTypes() -> Set<String> {
    DIContainer.shared.getOptimizedTypes()
  }

  /// 자동 감지된 순환 의존성을 반환합니다.
  static func circularDependencies() -> Set<String> {
    DIContainer.shared.getDetectedCircularDependencies()
  }

  /// 자동 수집된 성능 통계를 반환합니다.
  static func stats() -> [String: Int] {
    DIContainer.shared.getUsageStatistics()
  }

  /// 특정 타입이 자동 최적화되었는지 확인합니다.
  static func isOptimized<T>(_ type: T.Type) -> Bool {
    DIContainer.shared.isAutoOptimized(type)
  }

  /// 자동 최적화 기능을 제어합니다.
  static func setAutoOptimization(_ enabled: Bool = true) {
#if DEBUG && DI_MONITORING_ENABLED
    Task { @DIActor in AutoDIOptimizer.shared.setOptimizationEnabled(enabled) }
#endif
  }

  /// 자동 수집된 통계를 초기화합니다.
  static func resetStats() {
    DIContainer.shared.resetAutoStats()
  }

  /// AutoDIOptimizer의 로깅 레벨을 설정합니다.
  static func setAutoOptimizerLogLevel(_ level: UnifiedDI.LogLevel) {
    let mapped: AutoDIOptimizer.LogLevel
    switch level {
    case .all: mapped = .all
    case .registration: mapped = .registration
    case .performance: mapped = .optimization
    case .health: mapped = .errors
    case .errors, .warnings: mapped = .errors
    case .off: mapped = .off
    }
    Task { @DIActor in
      AutoDIOptimizer.shared.setLogLevel(mapped)
    }
  }

  /// 현재 로깅 레벨을 반환합니다 (비동기).
  static func getLogLevel() async -> UnifiedDI.LogLevel {
    mapLogLevel(DILogger.getCurrentLogLevel())
  }

  /// 현재 로깅 레벨(동기 스냅샷).
  static var logLevel: UnifiedDI.LogLevel {
    mapLogLevel(DILogger.getCurrentLogLevel())
  }

  /// 자동 Actor 최적화 제안.
  static var actorOptimizations: [String: ActorOptimization] {
    get async {
      let regs = AutoDIOptimizer.readSnapshot().registered
      var out: [String: ActorOptimization] = [:]
      for type in regs where type.contains("Actor") {
        out[type] = ActorOptimization(suggestion: "Actor 타입 감지됨")
      }
      return out
    }
  }

  /// 타입 안전성 이슈 목록.
  static var typeSafetyIssues: [String: TypeSafetyIssue] {
    get async {
      let regs = AutoDIOptimizer.readSnapshot().registered
      var issues: [String: TypeSafetyIssue] = [:]
      for type in regs where type.contains("Unsafe") {
        issues[type] = TypeSafetyIssue(issue: "Unsafe 타입 사용 감지")
      }
      return issues
    }
  }

  /// 사용 빈도 상위 타입.
  static var autoFixedTypes: Set<String> {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      return Set(freq.sorted { $0.value > $1.value }.prefix(3).map { $0.key })
    }
  }

  /// Actor hop 통계.
  static var actorHopStats: [String: Int] {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      return freq.filter { $0.key.contains("Actor") }
    }
  }

  /// 비동기 성능 통계.
  static var asyncPerformanceStats: [String: Double] {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      var stats: [String: Double] = [:]
      for (type, count) in freq where type.lowercased().contains("async") {
        stats[type] = Double(count) * 0.1
      }
      return stats
    }
  }

  /// 모니터링 상태 초기화.
  static func resetMonitoring() async {
    await AutoDIOptimizer.shared.reset()
    await AutoMonitor.shared.reset()
  }

  /// 레지스트리 동기화 상태 검증.
  static func verifyRegistryHealth() async -> RegistrySyncReport {
    await UnifiedRegistry.shared.verifyRegistrySync()
  }

  /// 레지스트리 자동 복구.
  static func autoFixRegistry() async -> RegistryFixReport {
    await UnifiedRegistry.shared.attemptRegistryAutoFix()
  }

  /// 레지스트리 건강성 점수.
  static func getRegistryHealthScore() async -> Double {
    let report = await UnifiedRegistry.shared.verifyRegistrySync()
    return report.healthScore
  }

  /// 레지스트리 상태 요약 출력.
  static func printRegistryStatus() async {
    let report = await verifyRegistryHealth()
    DILogger.info("📊 WeaveDI Registry Status:")
    DILogger.info(report.summary)

    if report.healthScore < 90.0 {
      DILogger.info("💡 Suggestions:")
      if !report.factoryInconsistencies.isEmpty {
        DILogger.info(channel: .registration, "  • Fix duplicate registrations: \(report.factoryInconsistencies.joined(separator: ", "))")
      }
      if !report.optimizationStats.isEnabled && report.totalRegistrations > 5 {
        DILogger.info(channel: .optimization, "  • Consider enabling optimization: GlobalUnifiedRegistry.enableOptimization()")
      }
    } else {
      DILogger.info(channel: .health, "✅ Registry is in excellent health!")
    }
  }
}

private extension UnifiedDI {
  static func mapLogLevel(_ level: DILogLevel) -> UnifiedDI.LogLevel {
    switch level {
    case .all: return .all
    case .registration: return .registration
    case .optimization: return .performance
    case .health: return .health
    case .errorsOnly: return .errors
    case .off: return .off
    }
  }
}

// MARK: - Component Metadata Diagnostics

public extension UnifiedDI {
  struct ComponentDiagnostics: Codable, Sendable {
    public struct Issue: Codable, Sendable {
      public let type: String
      public let providers: [String]
      public let detail: String?
    }

    public let issues: [Issue]

    public init(issues: [Issue]) {
      self.issues = issues
    }
  }

  struct ComponentCycleReport: Codable, Sendable {
    public let cycles: [[String]]
    public let componentCount: Int
    public let edgeCount: Int

    public init(cycles: [[String]], componentCount: Int, edgeCount: Int) {
      self.cycles = cycles
      self.edgeCount = edgeCount
    }
  }

  static func componentMetadata() -> [ComponentMetadata] {
    ComponentMetadataRegistry.allMetadata()
  }

  static func dumpComponentMetadata() -> String {
    ComponentMetadataRegistry.dumpMetadata()
  }

  static func analyzeComponentMetadata() -> ComponentDiagnostics {
    let metadata = ComponentMetadataRegistry.allMetadata()
    var typeProviders: [String: [(component: String, scope: String)]] = [:]

    for meta in metadata {
      for (index, typeName) in meta.providedTypes.enumerated() {
        let scope = index < meta.scopes.count ? meta.scopes[index] : "unknown"
        typeProviders[typeName, default: []].append((meta.componentName, scope))
      }
    }

    var issues: [ComponentDiagnostics.Issue] = []

    for (type, entries) in typeProviders {
      let components = entries.map { $0.component }
      let uniqueComponents = Array(Set(components))
      if uniqueComponents.count > 1 {
        issues.append(.init(type: type,
                            providers: uniqueComponents,
                            detail: "Multiple components provide this type."))
      }

      let scopes = entries.map { $0.scope }
      let uniqueScopes = Array(Set(scopes))
      if uniqueScopes.count > 1 {
        issues.append(.init(type: type,
                            providers: uniqueComponents,
                            detail: "Inconsistent scopes: \(uniqueScopes.joined(separator: ", "))"))
      }
    }

    return ComponentDiagnostics(issues: issues)
  }

  static func detectComponentCycles() -> ComponentCycleReport {
    let metadata = ComponentMetadataRegistry.allMetadata()
    let componentNames = Set(metadata.map { $0.componentName })
    var graph: [String: [String]] = [:]
    var edgeCount = 0

    for meta in metadata {
      let neighbors = meta.providedTypes.filter { componentNames.contains($0) }
      if !neighbors.isEmpty {
        graph[meta.componentName, default: []].append(contentsOf: neighbors)
        edgeCount += neighbors.count
      }
    }

    var recorded: Set<String> = []
    var cycles: [[String]] = []

    func visit(start: String, current: String, path: inout [String]) {
      path.append(current)

      for neighbor in graph[current, default: []] {
        if neighbor == start {
          var cycle = path
          cycle.append(neighbor)
          let (key, normalized) = canonicalizeCycle(cycle)
          if !key.isEmpty && !recorded.contains(key) {
            recorded.insert(key)
            cycles.append(normalized)
          }
        } else if !path.contains(neighbor) {
          visit(start: start, current: neighbor, path: &path)
        }
      }

      path.removeLast()
    }

    for node in graph.keys.sorted() {
      var path: [String] = []
      visit(start: node, current: node, path: &path)
    }

    cycles.sort { $0.joined(separator: " -> ") < $1.joined(separator: " -> ") }

    return ComponentCycleReport(
      cycles: cycles,
      componentCount: metadata.count,
      edgeCount: edgeCount
    )
  }

  private static func canonicalizeCycle(_ cycle: [String]) -> (String, [String]) {
    guard !cycle.isEmpty else { return ("", []) }
    var trimmed = cycle
    if let first = trimmed.first, let last = trimmed.last, first == last {
      trimmed.removeLast()
    }
    guard !trimmed.isEmpty else { return ("", []) }

    func rotations(of array: [String]) -> [[String]] {
      guard !array.isEmpty else { return [[]] }
      return (0..<array.count).map { index in
        Array(array[index...]) + Array(array[..<index])
      }
    }

    let candidates = rotations(of: trimmed) + rotations(of: trimmed.reversed())
    var bestSequence: [String] = []
    var bestKey = ""
    for sequence in candidates {
      let key = sequence.joined(separator: " -> ")
      if bestKey.isEmpty || key < bestKey {
        bestKey = key
        bestSequence = sequence
      }
    }
    return (bestKey, bestSequence)
  }
}
