import Foundation

// MARK: - Auto DI Features & Diagnostics

public extension UnifiedDI {
  /// ìµœì í™” ì„¤ì •ì„ ê°„í¸í•˜ê²Œ ì¡°ì •í•©ë‹ˆë‹¤.
  static func configureOptimization(
    debounceMs: Int = 100,
    threshold: Int = 10,
    realTimeUpdate: Bool = true
  ) {
    Task { @DIActor in
      AutoDIOptimizer.shared.updateConfig("threshold: \(threshold), realTime: \(realTimeUpdate)")
      AutoDIOptimizer.shared.setDebounceInterval(ms: debounceMs)
    }
  }

  /// ê·¸ë˜í”„ ë³€ê²½ íˆìŠ¤í† ë¦¬ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
  static func getGraphChanges(limit: Int = 10) async -> [(timestamp: Date, changes: [String: NodeChangeType])] {
    let deps = Array(AutoDIOptimizer.readSnapshot().dependencies.prefix(limit))
    let now = Date()
    return deps.enumerated().map { index, dep in
      (timestamp: now.addingTimeInterval(-Double(index) * 60),
       changes: [dep.from: NodeChangeType(change: "added dependency to \(dep.to)")])
    }
  }

  /// ìë™ ìƒì„±ëœ ì˜ì¡´ì„± ê·¸ë˜í”„ë¥¼ ì‹œê°í™”í•©ë‹ˆë‹¤.
  static func autoGraph() -> String {
    DIContainer.shared.getAutoGeneratedGraph()
  }

  /// ìë™ ìµœì í™”ëœ íƒ€ì…ë“¤ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
  static func optimizedTypes() -> Set<String> {
    DIContainer.shared.getOptimizedTypes()
  }

  /// ìë™ ê°ì§€ëœ ìˆœí™˜ ì˜ì¡´ì„±ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
  static func circularDependencies() -> Set<String> {
    DIContainer.shared.getDetectedCircularDependencies()
  }

  /// ìë™ ìˆ˜ì§‘ëœ ì„±ëŠ¥ í†µê³„ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  static func stats() -> [String: Int] {
    DIContainer.shared.getUsageStatistics()
  }

  /// íŠ¹ì • íƒ€ì…ì´ ìë™ ìµœì í™”ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
  static func isOptimized<T>(_ type: T.Type) -> Bool {
    DIContainer.shared.isAutoOptimized(type)
  }

  /// ìë™ ìµœì í™” ê¸°ëŠ¥ì„ ì œì–´í•©ë‹ˆë‹¤.
  static func setAutoOptimization(_ enabled: Bool = true) {
    Task { @DIActor in AutoDIOptimizer.shared.setOptimizationEnabled(enabled) }
  }

  /// ìë™ ìˆ˜ì§‘ëœ í†µê³„ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
  static func resetStats() {
    DIContainer.shared.resetAutoStats()
  }

  /// AutoDIOptimizerì˜ ë¡œê¹… ë ˆë²¨ì„ ì„¤ì •í•©ë‹ˆë‹¤.
  static func setAutoOptimizerLogLevel(_ level: UnifiedDI.LogLevel) {
    let mapped: AutoDIOptimizer.LogLevel
    switch level {
    case .all: mapped = .all
    case .registration: mapped = .registration
    case .performance: mapped = .optimization
    case .health: mapped = .errors
    case .errors, .warnings: mapped = .errors
    case .off: mapped = .off
    }
    Task { @DIActor in
      AutoDIOptimizer.shared.setLogLevel(mapped)
    }
  }

  /// í˜„ì¬ ë¡œê¹… ë ˆë²¨ì„ ë°˜í™˜í•©ë‹ˆë‹¤ (ë¹„ë™ê¸°).
  static func getLogLevel() async -> UnifiedDI.LogLevel {
    mapLogLevel(DILogger.getCurrentLogLevel())
  }

  /// í˜„ì¬ ë¡œê¹… ë ˆë²¨(ë™ê¸° ìŠ¤ëƒ…ìƒ·).
  static var logLevel: UnifiedDI.LogLevel {
    mapLogLevel(DILogger.getCurrentLogLevel())
  }

  /// ìë™ Actor ìµœì í™” ì œì•ˆ.
  static var actorOptimizations: [String: ActorOptimization] {
    get async {
      let regs = AutoDIOptimizer.readSnapshot().registered
      var out: [String: ActorOptimization] = [:]
      for type in regs where type.contains("Actor") {
        out[type] = ActorOptimization(suggestion: "Actor íƒ€ì… ê°ì§€ë¨")
      }
      return out
    }
  }

  /// íƒ€ì… ì•ˆì „ì„± ì´ìŠˆ ëª©ë¡.
  static var typeSafetyIssues: [String: TypeSafetyIssue] {
    get async {
      let regs = AutoDIOptimizer.readSnapshot().registered
      var issues: [String: TypeSafetyIssue] = [:]
      for type in regs where type.contains("Unsafe") {
        issues[type] = TypeSafetyIssue(issue: "Unsafe íƒ€ì… ì‚¬ìš© ê°ì§€")
      }
      return issues
    }
  }

  /// ì‚¬ìš© ë¹ˆë„ ìƒìœ„ íƒ€ì….
  static var autoFixedTypes: Set<String> {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      return Set(freq.sorted { $0.value > $1.value }.prefix(3).map { $0.key })
    }
  }

  /// Actor hop í†µê³„.
  static var actorHopStats: [String: Int] {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      return freq.filter { $0.key.contains("Actor") }
    }
  }

  /// ë¹„ë™ê¸° ì„±ëŠ¥ í†µê³„.


  static func staticResolve<T>(_ type: T.Type) -> T? where T: Sendable {
#if USE_STATIC_FACTORY
    return _staticFactoryResolve(type)
#else
    return resolve(type)
#endif
  }

#if USE_STATIC_FACTORY
  private static func _staticFactoryResolve<T>(_ type: T.Type) -> T? {
    return WeaveDI.Container.live.resolve(type)
  }
#endif


  static func registerBulkAsync<T: Sendable>(_ registrations: [(T.Type, @Sendable () async -> T)]) async {
    await withTaskGroup(of: Void.self) { group in
      for (type, factory) in registrations {
        group.addTask {
          _ = await registerAsync(type, factory: factory)
        }
      }
    }
    DILogger.info(channel: .registration, "ğŸš€ Bulk registered \(registrations.count) dependencies")
  }


  static func getMemoryUsageAsync() async -> (registeredCount: Int, singletonCount: Int) {
    return (registeredCount: 0, singletonCount: 0)
  }

  static func clearAsync() async {
    DILogger.info("ğŸ§¹ UnifiedDI async clear completed")
  }

  static var asyncPerformanceStats: [String: Double] {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      var stats: [String: Double] = [:]
      for (type, count) in freq where type.lowercased().contains("async") {
        stats[type] = Double(count) * 0.1
      }
      return stats
    }
  }

  /// ëª¨ë‹ˆí„°ë§ ìƒíƒœ ì´ˆê¸°í™”.
  static func resetMonitoring() async {
    await AutoDIOptimizer.shared.reset()
    await AutoMonitor.shared.reset()
  }

  /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë™ê¸°í™” ìƒíƒœ ê²€ì¦.
  static func verifyRegistryHealth() async -> RegistrySyncReport {
    await UnifiedRegistry.shared.verifyRegistrySync()
  }

  /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìë™ ë³µêµ¬.
  static func autoFixRegistry() async -> RegistryFixReport {
    await UnifiedRegistry.shared.attemptRegistryAutoFix()
  }

  /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ê±´ê°•ì„± ì ìˆ˜.
  static func getRegistryHealthScore() async -> Double {
    let report = await UnifiedRegistry.shared.verifyRegistrySync()
    return report.healthScore
  }

  /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìƒíƒœ ìš”ì•½ ì¶œë ¥.
  static func printRegistryStatus() async {
    let report = await verifyRegistryHealth()
    DILogger.info("ğŸ“Š WeaveDI Registry Status:")
    DILogger.info(report.summary)

    if report.healthScore < 90.0 {
      DILogger.info("ğŸ’¡ Suggestions:")
      if !report.factoryInconsistencies.isEmpty {
        DILogger.info(channel: .registration, "  â€¢ Fix duplicate registrations: \(report.factoryInconsistencies.joined(separator: ", "))")
      }
      if !report.optimizationStats.isEnabled && report.totalRegistrations > 5 {
        DILogger.info(channel: .optimization, "  â€¢ Consider enabling optimization: GlobalUnifiedRegistry.enableOptimization()")
      }
    } else {
      DILogger.info(channel: .health, "âœ… Registry is in excellent health!")
    }
  }
}

private extension UnifiedDI {
  static func mapLogLevel(_ level: DILogLevel) -> UnifiedDI.LogLevel {
    switch level {
    case .all: return .all
    case .registration: return .registration
    case .optimization: return .performance
    case .health: return .health
    case .errorsOnly: return .errors
    case .off: return .off
    }
  }
}
