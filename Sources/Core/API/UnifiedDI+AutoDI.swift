import Foundation

// MARK: - Auto DI Features

public extension UnifiedDI {
  static func autoGraph() -> String {
    DIContainer.shared.getAutoGeneratedGraph()
  }
  
  static func optimizedTypes() -> Set<String> {
    DIContainer.shared.getOptimizedTypes()
  }
  
  static func circularDependencies() -> Set<String> {
    DIContainer.shared.getDetectedCircularDependencies()
  }
  
  static func stats() -> [String: Int] {
    DIContainer.shared.getUsageStatistics()
  }
  
  static func isOptimized<T>(_ type: T.Type) -> Bool {
    DIContainer.shared.isAutoOptimized(type)
  }
  
  static func setAutoOptimization(_ enabled: Bool) {
    DIContainer.shared.setAutoOptimization(enabled)
  }
  
  static func resetStats() {
    DIContainer.shared.resetAutoStats()
  }
  
  static func setAutoOptimizerLogLevel(_ level: UnifiedDI.LogLevel) {
    let mapped: AutoDIOptimizer.LogLevel
    switch level {
    case .all: mapped = .all
    case .registration: mapped = .registration
    case .performance: mapped = .optimization
    case .errors, .warnings: mapped = .errors
    case .health: mapped = .errors
    case .off: mapped = .off
    }
    Task { @DIActor in
      AutoDIOptimizer.shared.setLogLevel(mapped)
    }
  }

  static func getLogLevel() async -> UnifiedDI.LogLevel {
    let current = DILogger.getCurrentLogLevel()
    switch current {
    case .all: return .all
    case .registration: return .registration
    case .optimization: return .performance
    case .health: return .health
    case .errorsOnly: return .errors
    case .off: return .off
    }
  }

  static var logLevel: UnifiedDI.LogLevel {
    let current = DILogger.getCurrentLogLevel()
    switch current {
    case .all: return .all
    case .registration: return .registration
    case .optimization: return .performance
    case .health: return .health
    case .errorsOnly: return .errors
    case .off: return .off
    }
  }
  
  static var actorOptimizations: [String: ActorOptimization] {
    get async {
      let regs = AutoDIOptimizer.readSnapshot().registered
      var out: [String: ActorOptimization] = [:]
      for type in regs where type.contains("Actor") {
        out[type] = ActorOptimization(suggestion: "Actor 타입 감지됨")
      }
      return out
    }
  }
  
  static var typeSafetyIssues: [String: TypeSafetyIssue] {
    get async {
      let regs = AutoDIOptimizer.readSnapshot().registered
      var issues: [String: TypeSafetyIssue] = [:]
      for type in regs where type.contains("Unsafe") {
        issues[type] = TypeSafetyIssue(issue: "Unsafe 타입 사용 감지")
      }
      return issues
    }
  }
  
  static var autoFixedTypes: Set<String> {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      return Set(freq.sorted { $0.value > $1.value }.prefix(3).map { $0.key })
    }
  }
  
  static var actorHopStats: [String: Int] {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      return freq.filter { $0.key.contains("Actor") }
    }
  }
  
  static var asyncPerformanceStats: [String: Double] {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      var stats: [String: Double] = [:]
      for (type, count) in freq where type.contains("async") || type.contains("Async") {
        stats[type] = Double(count) * 0.1
      }
      return stats
    }
  }
}
