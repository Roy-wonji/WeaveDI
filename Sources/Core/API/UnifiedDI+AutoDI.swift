import Foundation

// MARK: - Auto DI Features & Diagnostics

public extension UnifiedDI {
  /// ìµœì í™” ì„¤ì •ì„ ê°„í¸í•˜ê²Œ ì¡°ì •í•©ë‹ˆë‹¤.
  static func configureOptimization(
    debounceMs: Int = 100,
    threshold: Int = 10,
    realTimeUpdate: Bool = true
  ) {
    Task { @DIActor in
      AutoDIOptimizer.shared.updateConfig("threshold: \(threshold), realTime: \(realTimeUpdate)")
      AutoDIOptimizer.shared.setDebounceInterval(ms: debounceMs)
    }
  }

  /// ê·¸ë˜í”„ ë³€ê²½ íˆìŠ¤í† ë¦¬ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
  static func getGraphChanges(limit: Int = 10) async -> [(timestamp: Date, changes: [String: NodeChangeType])] {
    let deps = Array(AutoDIOptimizer.readSnapshot().dependencies.prefix(limit))
    let now = Date()
    return deps.enumerated().map { index, dep in
      (timestamp: now.addingTimeInterval(-Double(index) * 60),
       changes: [dep.from: NodeChangeType(change: "added dependency to \(dep.to)")])
    }
  }

  /// ìë™ ìƒì„±ëœ ì˜ì¡´ì„± ê·¸ë˜í”„ë¥¼ ì‹œê°í™”í•©ë‹ˆë‹¤.
  static func autoGraph() -> String {
    DIContainer.shared.getAutoGeneratedGraph()
  }

  /// ìë™ ìµœì í™”ëœ íƒ€ì…ë“¤ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
  static func optimizedTypes() -> Set<String> {
    DIContainer.shared.getOptimizedTypes()
  }

  /// ìë™ ê°ì§€ëœ ìˆœí™˜ ì˜ì¡´ì„±ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
  static func circularDependencies() -> Set<String> {
    DIContainer.shared.getDetectedCircularDependencies()
  }

  /// ìë™ ìˆ˜ì§‘ëœ ì„±ëŠ¥ í†µê³„ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  static func stats() -> [String: Int] {
    DIContainer.shared.getUsageStatistics()
  }

  /// íŠ¹ì • íƒ€ì…ì´ ìë™ ìµœì í™”ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
  static func isOptimized<T>(_ type: T.Type) -> Bool {
    DIContainer.shared.isAutoOptimized(type)
  }

  /// ìë™ ìµœì í™” ê¸°ëŠ¥ì„ ì œì–´í•©ë‹ˆë‹¤.
  static func setAutoOptimization(_ enabled: Bool = true) {
#if DEBUG && DI_MONITORING_ENABLED
    Task { @DIActor in AutoDIOptimizer.shared.setOptimizationEnabled(enabled) }
#endif
  }

  /// ìë™ ìˆ˜ì§‘ëœ í†µê³„ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
  static func resetStats() {
    DIContainer.shared.resetAutoStats()
  }

  /// AutoDIOptimizerì˜ ë¡œê¹… ë ˆë²¨ì„ ì„¤ì •í•©ë‹ˆë‹¤.
  static func setAutoOptimizerLogLevel(_ level: UnifiedDI.LogLevel) {
    let mapped: AutoDIOptimizer.LogLevel
    switch level {
    case .all: mapped = .all
    case .registration: mapped = .registration
    case .performance: mapped = .optimization
    case .health: mapped = .errors
    case .errors, .warnings: mapped = .errors
    case .off: mapped = .off
    }
    Task { @DIActor in
      AutoDIOptimizer.shared.setLogLevel(mapped)
    }
  }

  /// í˜„ì¬ ë¡œê¹… ë ˆë²¨ì„ ë°˜í™˜í•©ë‹ˆë‹¤ (ë¹„ë™ê¸°).
  static func getLogLevel() async -> UnifiedDI.LogLevel {
    mapLogLevel(DILogger.getCurrentLogLevel())
  }

  /// í˜„ì¬ ë¡œê¹… ë ˆë²¨(ë™ê¸° ìŠ¤ëƒ…ìƒ·).
  static var logLevel: UnifiedDI.LogLevel {
    mapLogLevel(DILogger.getCurrentLogLevel())
  }

  /// ìë™ Actor ìµœì í™” ì œì•ˆ.
  static var actorOptimizations: [String: ActorOptimization] {
    get async {
      let regs = AutoDIOptimizer.readSnapshot().registered
      var out: [String: ActorOptimization] = [:]
      for type in regs where type.contains("Actor") {
        out[type] = ActorOptimization(suggestion: "Actor íƒ€ì… ê°ì§€ë¨")
      }
      return out
    }
  }

  /// íƒ€ì… ì•ˆì „ì„± ì´ìŠˆ ëª©ë¡.
  static var typeSafetyIssues: [String: TypeSafetyIssue] {
    get async {
      let regs = AutoDIOptimizer.readSnapshot().registered
      var issues: [String: TypeSafetyIssue] = [:]
      for type in regs where type.contains("Unsafe") {
        issues[type] = TypeSafetyIssue(issue: "Unsafe íƒ€ì… ì‚¬ìš© ê°ì§€")
      }
      return issues
    }
  }

  /// ì‚¬ìš© ë¹ˆë„ ìƒìœ„ íƒ€ì….
  static var autoFixedTypes: Set<String> {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      return Set(freq.sorted { $0.value > $1.value }.prefix(3).map { $0.key })
    }
  }

  /// Actor hop í†µê³„.
  static var actorHopStats: [String: Int] {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      return freq.filter { $0.key.contains("Actor") }
    }
  }

  /// ë¹„ë™ê¸° ì„±ëŠ¥ í†µê³„.
  static var asyncPerformanceStats: [String: Double] {
    get async {
      let freq = AutoDIOptimizer.readSnapshot().frequentlyUsed
      var stats: [String: Double] = [:]
      for (type, count) in freq where type.lowercased().contains("async") {
        stats[type] = Double(count) * 0.1
      }
      return stats
    }
  }

  /// ëª¨ë‹ˆí„°ë§ ìƒíƒœ ì´ˆê¸°í™”.
  static func resetMonitoring() async {
    await AutoDIOptimizer.shared.reset()
    await AutoMonitor.shared.reset()
  }

  /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë™ê¸°í™” ìƒíƒœ ê²€ì¦.
  static func verifyRegistryHealth() async -> RegistrySyncReport {
    await UnifiedRegistry.shared.verifyRegistrySync()
  }

  /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìë™ ë³µêµ¬.
  static func autoFixRegistry() async -> RegistryFixReport {
    await UnifiedRegistry.shared.attemptRegistryAutoFix()
  }

  /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ê±´ê°•ì„± ì ìˆ˜.
  static func getRegistryHealthScore() async -> Double {
    let report = await UnifiedRegistry.shared.verifyRegistrySync()
    return report.healthScore
  }

  /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìƒíƒœ ìš”ì•½ ì¶œë ¥.
  static func printRegistryStatus() async {
    let report = await verifyRegistryHealth()
    DILogger.info("ğŸ“Š WeaveDI Registry Status:")
    DILogger.info(report.summary)

    if report.healthScore < 90.0 {
      DILogger.info("ğŸ’¡ Suggestions:")
      if !report.factoryInconsistencies.isEmpty {
        DILogger.info(channel: .registration, "  â€¢ Fix duplicate registrations: \(report.factoryInconsistencies.joined(separator: ", "))")
      }
      if !report.optimizationStats.isEnabled && report.totalRegistrations > 5 {
        DILogger.info(channel: .optimization, "  â€¢ Consider enabling optimization: GlobalUnifiedRegistry.enableOptimization()")
      }
    } else {
      DILogger.info(channel: .health, "âœ… Registry is in excellent health!")
    }
  }
}

private extension UnifiedDI {
  static func mapLogLevel(_ level: DILogLevel) -> UnifiedDI.LogLevel {
    switch level {
    case .all: return .all
    case .registration: return .registration
    case .optimization: return .performance
    case .health: return .health
    case .errorsOnly: return .errors
    case .off: return .off
    }
  }
}

// MARK: - Component Metadata Diagnostics

public extension UnifiedDI {
  struct ComponentDiagnostics: Codable, Sendable {
    public struct Issue: Codable, Sendable {
      public let type: String
      public let providers: [String]
      public let detail: String?
    }

    public let issues: [Issue]

    public init(issues: [Issue]) {
      self.issues = issues
    }
  }

  struct ComponentCycleReport: Codable, Sendable {
    public let cycles: [[String]]
    public let componentCount: Int
    public let edgeCount: Int

    public init(cycles: [[String]], componentCount: Int, edgeCount: Int) {
      self.cycles = cycles
      self.edgeCount = edgeCount
    }
  }

  static func componentMetadata() -> [ComponentMetadata] {
    ComponentMetadataRegistry.allMetadata()
  }

  static func dumpComponentMetadata() -> String {
    ComponentMetadataRegistry.dumpMetadata()
  }

  static func analyzeComponentMetadata() -> ComponentDiagnostics {
    let metadata = ComponentMetadataRegistry.allMetadata()
    var typeProviders: [String: [(component: String, scope: String)]] = [:]

    for meta in metadata {
      for (index, typeName) in meta.providedTypes.enumerated() {
        let scope = index < meta.scopes.count ? meta.scopes[index] : "unknown"
        typeProviders[typeName, default: []].append((meta.componentName, scope))
      }
    }

    var issues: [ComponentDiagnostics.Issue] = []

    for (type, entries) in typeProviders {
      let components = entries.map { $0.component }
      let uniqueComponents = Array(Set(components))
      if uniqueComponents.count > 1 {
        issues.append(.init(type: type,
                            providers: uniqueComponents,
                            detail: "Multiple components provide this type."))
      }

      let scopes = entries.map { $0.scope }
      let uniqueScopes = Array(Set(scopes))
      if uniqueScopes.count > 1 {
        issues.append(.init(type: type,
                            providers: uniqueComponents,
                            detail: "Inconsistent scopes: \(uniqueScopes.joined(separator: ", "))"))
      }
    }

    return ComponentDiagnostics(issues: issues)
  }

  static func detectComponentCycles() -> ComponentCycleReport {
    let metadata = ComponentMetadataRegistry.allMetadata()
    let componentNames = Set(metadata.map { $0.componentName })
    var graph: [String: [String]] = [:]
    var edgeCount = 0

    for meta in metadata {
      let neighbors = meta.providedTypes.filter { componentNames.contains($0) }
      if !neighbors.isEmpty {
        graph[meta.componentName, default: []].append(contentsOf: neighbors)
        edgeCount += neighbors.count
      }
    }

    var recorded: Set<String> = []
    var cycles: [[String]] = []

    func visit(start: String, current: String, path: inout [String]) {
      path.append(current)

      for neighbor in graph[current, default: []] {
        if neighbor == start {
          var cycle = path
          cycle.append(neighbor)
          let (key, normalized) = canonicalizeCycle(cycle)
          if !key.isEmpty && !recorded.contains(key) {
            recorded.insert(key)
            cycles.append(normalized)
          }
        } else if !path.contains(neighbor) {
          visit(start: start, current: neighbor, path: &path)
        }
      }

      path.removeLast()
    }

    for node in graph.keys.sorted() {
      var path: [String] = []
      visit(start: node, current: node, path: &path)
    }

    cycles.sort { $0.joined(separator: " -> ") < $1.joined(separator: " -> ") }

    return ComponentCycleReport(
      cycles: cycles,
      componentCount: metadata.count,
      edgeCount: edgeCount
    )
  }

  private static func canonicalizeCycle(_ cycle: [String]) -> (String, [String]) {
    guard !cycle.isEmpty else { return ("", []) }
    var trimmed = cycle
    if let first = trimmed.first, let last = trimmed.last, first == last {
      trimmed.removeLast()
    }
    guard !trimmed.isEmpty else { return ("", []) }

    func rotations(of array: [String]) -> [[String]] {
      guard !array.isEmpty else { return [[]] }
      return (0..<array.count).map { index in
        Array(array[index...]) + Array(array[..<index])
      }
    }

    let candidates = rotations(of: trimmed) + rotations(of: trimmed.reversed())
    var bestSequence: [String] = []
    var bestKey = ""
    for sequence in candidates {
      let key = sequence.joined(separator: " -> ")
      if bestKey.isEmpty || key < bestKey {
        bestKey = key
        bestSequence = sequence
      }
    }
    return (bestKey, bestSequence)
  }
}
