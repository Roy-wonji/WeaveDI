# Troubleshooting Guide

Common issues and solutions when using WeaveDI in your applications.

## Table of Contents

1. [Dependency Resolution Issues](#dependency-resolution-issues)
2. [Circular Dependencies](#circular-dependencies)
3. [Memory Leaks](#memory-leaks)
4. [Performance Problems](#performance-problems)
5. [Actor Isolation Errors](#actor-isolation-errors)
6. [Testing Issues](#testing-issues)
7. [Build and Compilation Errors](#build-and-compilation-errors)

## Dependency Resolution Issues

### Issue: Dependency Returns Nil

**Symptoms:**
```swift
@Inject var userService: UserService?

func loadUser() {
    guard let service = userService else {
        print("❌ UserService is nil!")  // This prints
        return
    }
}
```

**Causes:**
1. Dependency not registered
2. Wrong type registered
3. Registration happened after resolution

**Solutions:**

**Solution 1: Verify Registration**
```swift
// Check if dependency is registered
await WeaveDI.Container.bootstrap { container in
    container.register(UserService.self) {
        UserServiceImpl()
    }
    print("✅ UserService registered")
}

// Verify registration
let stats = await WeaveDI.Container.getUsageStatistics()
print("Registered types: \(stats)")
```

**Solution 2: Use @Injected with InjectedKey (v3.2.0+)**
```swift
// Define InjectedKey with fallback
struct UserServiceKey: InjectedKey {
    static var liveValue: UserService = UserServiceImpl()
}

extension InjectedValues {
    var userService: UserService {
        get { self[UserServiceKey.self] }
        set { self[UserServiceKey.self] = newValue }
    }
}

// Now it's never nil
@Injected(\.userService) var userService
```

**Solution 3: Ensure Bootstrap Completes**
```swift
@main
struct MyApp: App {
    init() {
        // Make sure bootstrap completes before app starts
        Task {
            await WeaveDI.Container.bootstrap { container in
                container.register(UserService.self) {
                    UserServiceImpl()
                }
            }
        }
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .task {
                    // Wait for bootstrap
                    try? await Task.sleep(nanoseconds: 100_000_000)
                }
        }
    }
}
```

### Issue: Wrong Type Resolved

**Symptoms:**
```swift
// Registered ProductionService but got TestService
@Injected(\.userService) var userService
print(type(of: userService))  // Prints: TestService instead of ProductionService
```

**Cause:**
Test value being used in production or multiple registrations.

**Solution:**
```swift
// Ensure correct environment
struct UserServiceKey: InjectedKey {
    static var liveValue: UserService {
        #if DEBUG
        print("⚠️ Using DEBUG liveValue")
        #endif
        return ProductionUserService()
    }

    static var testValue: UserService {
        return MockUserService()
    }
}

// Verify which value is active
func checkDependency() {
    let service = InjectedValues.current.userService
    print("Service type: \(type(of: service))")
}
```

## Circular Dependencies

### Issue: Infinite Loop or Crash at Startup

**Symptoms:**
```swift
// App crashes or hangs at startup
// Error: Stack overflow or infinite recursion

struct ServiceAKey: InjectedKey {
    static var liveValue: ServiceA {
        ServiceAImpl()  // Depends on ServiceB
    }
}

struct ServiceBKey: InjectedKey {
    static var liveValue: ServiceB {
        ServiceBImpl()  // Depends on ServiceA - Circular!
    }
}
```

**Diagnosis:**
```swift
// Check dependency graph
let graph = await WeaveDI.Container.getAutoGeneratedGraph()
print("Dependency graph:\n\(graph)")

// Check for circular dependencies
let circular = await WeaveDI.Container.getDetectedCircularDependencies()
if !circular.isEmpty {
    print("⚠️ Circular dependencies detected:")
    circular.forEach { print("  - \($0)") }
}
```

**Solution 1: Use Lazy Injection**
```swift
// Break the circle with lazy property injection
class ServiceAImpl: ServiceA {
    @Injected(\.serviceB) var serviceB  // Lazy - only resolved when accessed

    func doSomething() {
        // ServiceB only created when needed
        serviceB.performAction()
    }
}

struct ServiceAKey: InjectedKey {
    static var liveValue: ServiceA {
        ServiceAImpl()  // No immediate ServiceB creation
    }
}
```

**Solution 2: Introduce Abstraction Layer**
```swift
// Use event bus or mediator pattern
protocol EventBus {
    func publish(_ event: Event)
    func subscribe(_ handler: @escaping (Event) -> Void)
}

// Both services depend on EventBus instead of each other
class ServiceA {
    @Injected(\.eventBus) var eventBus

    func doSomething() {
        eventBus.publish(SomethingHappenedEvent())
    }
}

class ServiceB {
    @Injected(\.eventBus) var eventBus

    init() {
        eventBus.subscribe { event in
            // Handle event from ServiceA
        }
    }
}
```

**Solution 3: Protocol-Based Decoupling**
```swift
// Define protocols
protocol UserServiceDelegate: AnyObject {
    func userDidUpdate(_ user: User)
}

// ServiceA depends on protocol, not concrete ServiceB
class ServiceA {
    weak var delegate: UserServiceDelegate?

    func updateUser() {
        delegate?.userDidUpdate(user)
    }
}

// ServiceB conforms to protocol
class ServiceB: UserServiceDelegate {
    @Injected(\.serviceA) var serviceA

    init() {
        serviceA.delegate = self
    }

    func userDidUpdate(_ user: User) {
        // Handle update
    }
}
```

## Memory Leaks

### Issue: Memory Usage Grows Over Time

**Symptoms:**
```swift
// Memory keeps growing
// Services not deallocated when no longer needed
```

**Diagnosis:**
```swift
// Monitor memory
class MemoryMonitor {
    func checkMemory() {
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4

        let result = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
            }
        }

        if result == KERN_SUCCESS {
            let usedMB = Double(info.resident_size) / 1024.0 / 1024.0
            print("Memory used: \(usedMB) MB")
        }
    }
}
```

**Solution 1: Use Weak References**
```swift
// Avoid retain cycles with weak references
class ViewModel {
    @Injected(\.userService) var userService

    private weak var delegate: ViewModelDelegate?

    func setup(delegate: ViewModelDelegate) {
        self.delegate = delegate  // weak, not strong
    }
}
```

**Solution 2: Release Scoped Dependencies**
```swift
// Release session-scoped dependencies when done
class SessionManager {
    func logout() async {
        // Release session dependencies
        await WeaveDI.Container.releaseScope(.session)

        // Or release specific types
        await DIActor.shared.release(SessionService.self)
    }
}
```

**Solution 3: Use @Factory for Temporary Objects**
```swift
// Use @Factory for short-lived objects
class ReportGenerator {
    @Factory var pdfBuilder: PDFBuilder  // New instance each time

    func generateReport() {
        let builder = pdfBuilder  // Created
        let pdf = builder.build()
        // builder deallocated after use
        return pdf
    }
}
```

**Solution 4: Clear Caches Periodically**
```swift
// Clear hot cache when memory pressure
func handleMemoryWarning() {
    // System memory warning
    NotificationCenter.default.addObserver(
        forName: UIApplication.didReceiveMemoryWarningNotification,
        object: nil,
        queue: nil
    ) { _ in
        Task {
            // Release cached dependencies
            await WeaveDI.Container.releaseAll()
        }
    }
}
```

## Performance Problems

### Issue: Slow Dependency Resolution

**Symptoms:**
```swift
// Resolution takes too long
let start = Date()
let service = await UnifiedDI.resolve(UserService.self)
let duration = Date().timeIntervalSince(start)
print("Resolution took: \(duration)s")  // > 0.01s is slow
```

**Solution 1: Enable Optimization**
```swift
// Enable runtime optimization
UnifiedRegistry.shared.enableOptimization()

// Or use hot-path optimization
UnifiedDI.configureOptimization(
    hotPathThreshold: 10,  // Cache after 10 uses
    enableAutoOptimization: true
)
```

**Solution 2: Use @Injected Instead of Manual Resolution**
```swift
// ❌ Slow: Manual resolution in loop
for i in 0..<1000 {
    let service = await UnifiedDI.resolve(UserService.self)
    service.doSomething()
}

// ✅ Fast: Resolve once
@Injected(\.userService) var userService

for i in 0..<1000 {
    userService.doSomething()
}
```

**Solution 3: Reduce Dependency Count**
```swift
// ❌ Slow: Many dependencies
class ViewModel {
    @Injected(\.service1) var service1
    @Injected(\.service2) var service2
    @Injected(\.service3) var service3
    @Injected(\.service4) var service4
    @Injected(\.service5) var service5
    // ... 10 more
}

// ✅ Fast: Facade pattern
class ViewModel {
    @Injected(\.serviceFacade) var facade  // Single injection
}

class ServiceFacade {
    @Injected(\.service1) var service1
    @Injected(\.service2) var service2
    // Bundle related services
}
```

### Issue: High CPU Usage

**Symptoms:**
```swift
// CPU spikes when resolving dependencies
// Energy impact is high
```

**Solution: Optimize Factory Methods**
```swift
// ❌ Slow: Heavy computation in factory
struct ServiceKey: InjectedKey {
    static var liveValue: Service {
        // Heavy computation every time
        let config = loadConfig()  // Slow!
        let database = connectToDatabase()  // Slow!
        return ServiceImpl(config: config, database: database)
    }
}

// ✅ Fast: Lazy initialization
struct ServiceKey: InjectedKey {
    private static let cachedService = {
        let config = loadConfig()
        let database = connectToDatabase()
        return ServiceImpl(config: config, database: database)
    }()

    static var liveValue: Service {
        cachedService  // Return cached instance
    }
}
```

## Actor Isolation Errors

### Issue: Actor-Isolated Property Access Error

**Symptoms:**
```swift
// Error: Expression is 'async' but is not marked with 'await'
// Error: Call to actor-isolated instance method 'resolve' from outside its isolation context

@MainActor
class ViewModel {
    func loadData() {
        let service = DIActor.shared.resolve(UserService.self)  // ❌ Error!
    }
}
```

**Solution 1: Add await**
```swift
@MainActor
class ViewModel {
    func loadData() async {
        let service = await DIActor.shared.resolve(UserService.self)  // ✅ Fixed
    }
}
```

**Solution 2: Use @Injected (Recommended)**
```swift
@MainActor
class ViewModel {
    @Injected(\.userService) var userService  // ✅ No async needed

    func loadData() {
        // userService is available synchronously
        userService.fetchData()
    }
}
```

**Solution 3: Nonisolated Context**
```swift
class ViewModel {
    nonisolated func loadData() async {
        // Not isolated to actor
        let service = await DIActor.shared.resolve(UserService.self)
    }
}
```

### Issue: Sendable Conformance Error

**Symptoms:**
```swift
// Warning: Type 'UserService' does not conform to the 'Sendable' protocol
// Error: Passing argument of non-sendable type across actors

actor DataActor {
    func process() async {
        let service = await DIActor.shared.resolve(UserService.self)  // ⚠️ Warning
    }
}
```

**Solution 1: Make Type Sendable**
```swift
// Make your type conform to Sendable
protocol UserService: Sendable {
    func fetchUser(id: String) async -> User?
}

class UserServiceImpl: UserService {
    // Ensure all properties are Sendable
    private let apiClient: APIClient  // Must be Sendable
    private let queue: DispatchQueue  // Sendable
}
```

**Solution 2: Use @unchecked Sendable (Carefully)**
```swift
// Only if you're sure it's thread-safe
class UserServiceImpl: UserService, @unchecked Sendable {
    private let lock = NSLock()
    private var cache: [String: User] = [:]

    func fetchUser(id: String) async -> User? {
        lock.lock()
        defer { lock.unlock() }
        return cache[id]
    }
}
```

## Testing Issues

### Issue: Tests Fail with Old Dependencies

**Symptoms:**
```swift
// Test uses production service instead of mock
func testUserLogin() async {
    let viewModel = LoginViewModel()
    await viewModel.login(credentials: testCredentials)
    // Actual API call made! Should use mock
}
```

**Solution: Use withInjectedValues**
```swift
func testUserLogin() async {
    await withInjectedValues { values in
        values.authService = MockAuthService()  // Override
        values.userService = MockUserService()
    } operation: {
        let viewModel = LoginViewModel()
        await viewModel.login(credentials: testCredentials)
        // Now uses mocks
    }
}
```

### Issue: Tests Interfere with Each Other

**Symptoms:**
```swift
// Test A passes when run alone
// Test A fails when run with Test B
// Shared state between tests
```

**Solution 1: Use Scoped Overrides**
```swift
// Each test gets isolated dependencies
class UserServiceTests: XCTestCase {
    func testFetchUser() async {
        await withInjectedValues { values in
            values.userService = MockUserService()
        } operation: {
            // Test with isolated mock
        }
        // Automatically reverts after test
    }

    func testUpdateUser() async {
        await withInjectedValues { values in
            values.userService = MockUserService()  // Fresh mock
        } operation: {
            // Independent from other tests
        }
    }
}
```

**Solution 2: Reset Between Tests**
```swift
class ViewModelTests: XCTestCase {
    override func tearDown() async throws {
        // Clear any shared state
        await WeaveDI.Container.resetForTesting()
        try await super.tearDown()
    }
}
```

## Build and Compilation Errors

### Issue: Module 'WeaveDI' Not Found

**Symptoms:**
```swift
import WeaveDI  // ❌ Error: No such module 'WeaveDI'
```

**Solution 1: Verify Package Dependencies**
```swift
// Package.swift
dependencies: [
    .package(url: "https://github.com/Roy-wonji/WeaveDI.git", from: "3.2.0")
],
targets: [
    .target(
        name: "YourTarget",
        dependencies: ["WeaveDI"]  // Make sure this is added
    )
]
```

**Solution 2: Clean Build Folder**
```bash
# Xcode
# Product → Clean Build Folder (Cmd+Shift+K)

# SPM
swift package clean
swift package resolve
swift build
```

**Solution 3: Reset Package Caches**
```bash
# Xcode
# File → Packages → Reset Package Caches

# SPM
rm -rf .build
rm Package.resolved
swift package resolve
```

### Issue: Type Inference Failed

**Symptoms:**
```swift
// Error: Cannot infer type
@Injected(\.service) var service  // ❌ Error
```

**Solution: Explicit Type Annotation**
```swift
// Add explicit type
@Injected(\.service) var service: UserService  // ✅ Fixed
```

### Issue: Ambiguous Use of Property Wrapper

**Symptoms:**
```swift
// Error: Ambiguous use of 'Injected'
@Injected var service: UserService
```

**Solution: Use Full Syntax**
```swift
// v3.2.0+ requires KeyPath or type
@Injected(\.service) var service: UserService  // ✅ Fixed

// Or type-based
@Injected(UserServiceKey.self) var service: UserService
```

## Debugging Tips

### Enable Detailed Logging

```swift
// Set log level for debugging
UnifiedDI.setLogLevel(.all)  // See everything

// Or specific categories
UnifiedDI.setLogLevel(.registration)  // Only registration logs
UnifiedDI.setLogLevel(.optimization)  // Only optimization logs
```

### Inspect Dependency Graph

```swift
// Visualize dependencies
Task {
    let graph = await WeaveDI.Container.getAutoGeneratedGraph()
    print("Dependency Graph:")
    print(graph)

    // Check for issues
    let circular = await WeaveDI.Container.getDetectedCircularDependencies()
    if !circular.isEmpty {
        print("⚠️ Circular dependencies: \(circular)")
    }
}
```

### Monitor Performance

```swift
// Check performance statistics
Task {
    let stats = await UnifiedDI.asyncPerformanceStats
    print("Performance Stats:")
    stats.forEach { type, duration in
        print("\(type): \(duration)ms")
    }

    // Check hot cache hits
    let optimized = await UnifiedDI.optimizedTypes()
    print("Optimized types: \(optimized)")
}
```

### Verify Registration

```swift
// Check what's registered
Task {
    let stats = await WeaveDI.Container.getUsageStatistics()
    print("Registered types:")
    stats.registeredTypes.forEach { type in
        print("  - \(type)")
    }

    // Check if specific type is registered
    let isOptimized = await WeaveDI.Container.isAutoOptimized(UserService.self)
    print("UserService optimized: \(isOptimized)")
}
```

## Getting Help

Still having issues? Here's how to get help:

1. **Check Documentation**
   - [API Reference](../api/injected.md)
   - [Migration Guide](./migration-inject-to-injected.md)
   - [Best Practices](./bestPractices.md)

2. **Search Issues**
   - [GitHub Issues](https://github.com/Roy-wonji/WeaveDI/issues)
   - Search for similar problems

3. **Create Issue**
   - Include WeaveDI version
   - Include Swift version
   - Provide minimal reproduction code
   - Include error messages

4. **Ask Community**
   - Discussions tab on GitHub
   - Stack Overflow with `weavedi` tag

## Next Steps

- [Best Practices](./bestPractices.md) - Avoid common pitfalls
- [Performance Optimization](./runtimeOptimization.md) - Speed up your app
- [Testing Guide](../tutorial/testing.md) - Advanced testing strategies
