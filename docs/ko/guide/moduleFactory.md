# ëª¨ë“ˆ íŒ©í† ë¦¬ - ê³ ê¸‰ ì˜ì¡´ì„± ì¡°ì§í™”

WeaveDIì˜ ëª¨ë“ˆ íŒ©í† ë¦¬ ì‹œìŠ¤í…œì— ëŒ€í•œ í¬ê´„ì ì¸ ê°€ì´ë“œì…ë‹ˆë‹¤. ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì˜ì¡´ì„±ì„ ì¡°ì§í™”, ê´€ë¦¬, í™•ì¥í•˜ëŠ” ê°€ì¥ ê°•ë ¥í•œ ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤. ì´ ì‹œìŠ¤í…œì€ ë³µì¡í•œ ì˜ì¡´ì„± ê·¸ë˜í”„ë¥¼ ìœ„í•œ ì²´ê³„ì ì¸ ëª¨ë“ˆ ìƒì„±, ë“±ë¡, ê´€ë¦¬ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

## ê°œìš”

WeaveDIì˜ ëª¨ë“ˆ íŒ©í† ë¦¬ íŒ¨í„´ì€ ëŒ€ê·œëª¨ ì˜ì¡´ì„± ê´€ë¦¬ ë°©ì‹ì„ ë³€í™”ì‹œí‚µë‹ˆë‹¤. ë¶„ì‚°ëœ ë“±ë¡ ëŒ€ì‹ , êµ¬ì„± ê°€ëŠ¥í•˜ê³  í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•˜ë©° ìœ ì§€ë³´ìˆ˜ ê°€ëŠ¥í•œ ì˜ì¡´ì„± ëª¨ë“ˆì„ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ì¡°ì§í™”ëœ ì‹œìŠ¤í…œì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì£¼ìš” ì¥ì 

- **ğŸ—ï¸ ì²´ê³„ì  ì¡°ì§í™”**: ê´€ë ¨ ì˜ì¡´ì„±ë“¤ì„ ë…¼ë¦¬ì  ëª¨ë“ˆë¡œ ê·¸ë£¹í™”
- **ğŸ”§ íŒ©í† ë¦¬ íŒ¨í„´**: ì˜ì¡´ì„± ìƒì„±ì„ ìœ„í•œ ê²€ì¦ëœ íŒ©í† ë¦¬ ë””ìì¸ íŒ¨í„´ í™œìš©
- **ğŸ¯ íƒ€ì… ì•ˆì „ì„±**: ëª¨ë“ˆ ì˜ì¡´ì„±ì˜ ì»´íŒŒì¼ íƒ€ì„ ê²€ì¦
- **ğŸ§ª í…ŒìŠ¤íŒ… ì§€ì›**: ì‰¬ìš´ ëª© ì£¼ì…ê³¼ í…ŒìŠ¤íŠ¸ ê²©ë¦¬
- **âš¡ ì„±ëŠ¥**: ì§€ì—° ë¡œë”©ê³¼ ìµœì í™”ëœ ëª¨ë“ˆ ë“±ë¡
- **ğŸ“¦ ëª¨ë“ˆí™”**: ëŒ€ê·œëª¨ íŒ€ê³¼ ë³µì¡í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ì— ì™„ë²½

### ì•„í‚¤í…ì²˜ ì¥ì 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Application Layer            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚     ModuleFactoryManager    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚           â”‚           â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Repository â”‚ â”‚UseCase â”‚ â”‚  Service   â”‚
â”‚  Factory  â”‚ â”‚Factory â”‚ â”‚  Factory   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚           â”‚           â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         WeaveDI Container           â”‚
â”‚        (Registered Modules)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## í•µì‹¬ êµ¬ì„± ìš”ì†Œ

### ModuleFactory í”„ë¡œí† ì½œ

ì‹¤ì œ êµ¬í˜„ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ëª¨ë“ˆ ì‹œìŠ¤í…œì˜ ê¸°ì´ˆ:

```swift
public protocol ModuleFactory {
    var registerModule: RegisterModule { get }    // ëª¨ë“ˆ ìƒì„± ìœ í‹¸ë¦¬í‹°
    var definitions: [@Sendable () -> Module] { get set }  // ëª¨ë“ˆ ì •ì˜ë“¤
    func makeAllModules() -> [Module]  // ëª¨ë“  ëª¨ë“ˆì„ í•œ ë²ˆì— ìƒì„±
}
```

**í”„ë¡œí† ì½œ ì±…ì„:**
- **ëª¨ë“ˆ ì •ì˜ ì €ì¥**: ëª¨ë“ˆ ìƒì„± í´ë¡œì €ë“¤ì˜ ëª©ë¡ ìœ ì§€
- **ë°°ì¹˜ ìƒì„±**: íŒ©í† ë¦¬ì˜ ëª¨ë“  ëª¨ë“ˆì„ ë™ì‹œì— ìƒì„±
- **íƒ€ì… ì•ˆì „ì„±**: ëª¨ë“  ëª¨ë“ˆì´ ì ì ˆíˆ íƒ€ì… ì§€ì •ë˜ê³  Sendableí•¨ì„ ë³´ì¥
- **ì§€ì—° í‰ê°€**: `makeAllModules()`ê°€ í˜¸ì¶œë  ë•Œë§Œ ëª¨ë“ˆì´ ìƒì„±ë¨

### RegisterModule - ëª¨ë“ˆ ìƒì„± ì—”ì§„

ëª¨ë“  ëª¨ë“ˆ ìƒì„±ì„ ë‹´ë‹¹í•˜ëŠ” í•µì‹¬ ìœ í‹¸ë¦¬í‹°:

```swift
public struct RegisterModule: Sendable {
    // ê¸°ë³¸ ëª¨ë“ˆ ìƒì„± - ë‹¨ìˆœí•œ ì˜ì¡´ì„±ìš©
    public func makeModule<T>(
        _ type: T.Type,
        factory: @Sendable @escaping () -> T
    ) -> Module where T: Sendable

    // UseCase-Repository íŒ¨í„´ê³¼ ìë™ ì˜ì¡´ì„± ì£¼ì…ì„ ìœ„í•œ ê³ ê¸‰ ê¸°ëŠ¥
    public func makeUseCaseWithRepository<UseCase, Repo>(
        _ useCaseProtocol: UseCase.Type,      // ë“±ë¡í•  UseCase í”„ë¡œí† ì½œ
        repositoryProtocol: Repo.Type,        // í•„ìš”í•œ ë¦¬í¬ì§€í† ë¦¬ ì˜ì¡´ì„±
        repositoryFallback: @Sendable @autoclosure @escaping () -> Repo,  // ë¦¬í¬ì§€í† ë¦¬ë¥¼ ì°¾ì§€ ëª»í•  ë•Œ í´ë°±
        factory: @Sendable @escaping (Repo) -> UseCase  // ì£¼ì…ëœ ë¦¬í¬ì§€í† ë¦¬ë¡œ UseCase ìƒì„±
    ) -> @Sendable () -> Module where UseCase: Sendable

    // ì—¬ëŸ¬ ì˜ì¡´ì„±ì„ ê°€ì§„ ì˜ì¡´ì„± ì£¼ì…
    public func makeDependency<T>(
        _ type: T.Type,
        dependencies: [Any.Type] = [],
        factory: @Sendable @escaping () throws -> T
    ) -> Module where T: Sendable
}
```

**RegisterModule ê¸°ëŠ¥:**
- **ğŸ¯ íƒ€ì… ì•ˆì „ì„±**: ëª¨ë“  ëª¨ë“ˆì˜ ì»´íŒŒì¼ íƒ€ì„ íƒ€ì… ê²€ì‚¬
- **ğŸ”„ ì˜ì¡´ì„± ì£¼ì…**: ëª¨ë“ˆ ì˜ì¡´ì„±ì˜ ìë™ í•´ê²°
- **ğŸ›¡ï¸ í´ë°± ì§€ì›**: ëˆ„ë½ëœ ì˜ì¡´ì„±ì˜ ìš°ì•„í•œ ì²˜ë¦¬
- **âš¡ ì„±ëŠ¥**: ìµœì í™”ëœ ëª¨ë“ˆ ìƒì„±ê³¼ ë“±ë¡
- **ğŸ§µ ë™ì‹œì„±**: ì™„ì „í•œ Swift 6 sendable ì¤€ìˆ˜

## ê¸°ë³¸ ì‚¬ìš©ë²•

### ë‹¨ìˆœí•œ ëª¨ë“ˆ íŒ©í† ë¦¬

ê´€ë ¨ ì˜ì¡´ì„±ë“¤ì„ ìœ„í•œ ê¸°ë³¸ íŒ©í† ë¦¬ë¡œ ì‹œì‘:

```swift
struct RepositoryModuleFactory: ModuleFactory {
    var registerModule = RegisterModule()
    var definitions: [@Sendable () -> Module] = []

    mutating func setup() {
        // ë°ì´í„°ë² ì´ìŠ¤ ì˜ì¡´ì„±ì„ ê°€ì§„ ì‚¬ìš©ì ë¦¬í¬ì§€í† ë¦¬
        definitions.append {
            registerModule.makeModule(UserRepository.self) {
                UserRepositoryImpl(
                    database: WeaveDI.Container.shared.resolve(DatabaseService.self)!,
                    logger: WeaveDI.Container.shared.resolve(Logger.self)
                )
            }
        }

        // ìºì‹±ì„ ê°€ì§„ ë„ì„œ ë¦¬í¬ì§€í† ë¦¬
        definitions.append {
            registerModule.makeModule(BookRepository.self) {
                CachedBookRepository(
                    baseRepository: BookRepositoryImpl(),
                    cache: WeaveDI.Container.shared.resolve(CacheService.self)!
                )
            }
        }

        // ë³µì¡í•œ ì˜ì¡´ì„±ì„ ê°€ì§„ ì£¼ë¬¸ ë¦¬í¬ì§€í† ë¦¬
        definitions.append {
            registerModule.makeModule(OrderRepository.self) {
                OrderRepositoryImpl(
                    database: WeaveDI.Container.shared.resolve(DatabaseService.self)!,
                    paymentGateway: WeaveDI.Container.shared.resolve(PaymentGateway.self)!,
                    notificationService: WeaveDI.Container.shared.resolve(NotificationService.self)!
                )
            }
        }
    }

    func makeAllModules() -> [Module] {
        definitions.map { $0() }
    }
}
```

### ì˜¤ë¥˜ ì²˜ë¦¬ê°€ ê°•í™”ëœ íŒ©í† ë¦¬

```swift
struct SafeRepositoryModuleFactory: ModuleFactory {
    var registerModule = RegisterModule()
    var definitions: [@Sendable () -> Module] = []

    mutating func setup() {
        definitions.append {
            registerModule.makeModule(UserRepository.self) {
                do {
                    // ì›ê²© ë°ì´í„°ë² ì´ìŠ¤ë¡œ ìƒì„± ì‹œë„
                    let remoteDB = try RemoteDatabaseService.connect()
                    return RemoteUserRepository(database: remoteDB)
                } catch {
                    // ë¡œì»¬ ë°ì´í„°ë² ì´ìŠ¤ë¡œ í´ë°±
                    print("âš ï¸ ì›ê²© DBë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ì–´ ë¡œì»¬ ì‚¬ìš©: \(error)")
                    let localDB = LocalDatabaseService()
                    return LocalUserRepository(database: localDB)
                }
            }
        }
    }

    func makeAllModules() -> [Module] {
        definitions.map { $0() }
    }
}
```

### íŒ©í† ë¦¬ ë“±ë¡ê³¼ ì‚¬ìš©

#### ê¸°ë³¸ ë“±ë¡

```swift
// ì•± ì´ˆê¸°í™”
func initializeRepositories() async {
    var repositoryFactory = RepositoryModuleFactory()
    repositoryFactory.setup()

    let modules = repositoryFactory.makeAllModules()

    await WeaveDI.Container.bootstrap { container in
        for module in modules {
            await container.register(module)
        }
    }

    print("âœ… \(modules.count)ê°œ ë¦¬í¬ì§€í† ë¦¬ ëª¨ë“ˆì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤")
}
```

#### ê²€ì¦ì´ í¬í•¨ëœ ê³ ê¸‰ ë“±ë¡

```swift
func initializeWithValidation() async throws {
    var repositoryFactory = RepositoryModuleFactory()
    repositoryFactory.setup()

    let modules = repositoryFactory.makeAllModules()

    // ë“±ë¡ ì „ ëª¨ë“ˆ ê²€ì¦
    try validateModules(modules)

    await WeaveDI.Container.bootstrap { container in
        await withTaskGroup(of: Void.self) { group in
            for module in modules {
                group.addTask {
                    await container.register(module)
                    print("ğŸ“¦ ë“±ë¡ë¨: \(module.description)")
                }
            }
        }
    }
}

func validateModules(_ modules: [Module]) throws {
    guard !modules.isEmpty else {
        throw ModuleError.noModulesFound
    }

    for module in modules {
        guard module.isValid else {
            throw ModuleError.invalidModule(module.description)
        }
    }
}
```

## ê³ ê¸‰ íŒ¨í„´

### 1. ë‹¤ì¤‘ ëª¨ë“ˆ íŒ©í† ë¦¬ ì‹œìŠ¤í…œ

ë‹¤ì–‘í•œ ëª¨ë“ˆ íƒ€ì…ì„ ê´€ë¦¬í•˜ëŠ” í¬ê´„ì ì¸ ì‹œìŠ¤í…œ:

```swift
struct ApplicationModuleFactory {
    // ì„œë¡œ ë‹¤ë¥¸ ê´€ì‹¬ì‚¬ë¥¼ ìœ„í•œ ë‹¤ì–‘í•œ íŒ©í† ë¦¬ íƒ€ì…
    var infrastructureFactory = InfrastructureModuleFactory()
    var repositoryFactory = RepositoryModuleFactory()
    var useCaseFactory = UseCaseModuleFactory()
    var serviceFactory = ServiceModuleFactory()
    var presentationFactory = PresentationModuleFactory()

    let environment: Environment
    let configuration: AppConfiguration

    init(environment: Environment, configuration: AppConfiguration) {
        self.environment = environment
        self.configuration = configuration
    }

    mutating func setupAll() async {
        // ì˜ì¡´ì„± ìˆœì„œëŒ€ë¡œ ì„¤ì •
        await setupInfrastructure()
        await setupRepositories()
        await setupUseCases()
        await setupServices()
        await setupPresentation()
    }

    private mutating func setupInfrastructure() async {
        infrastructureFactory.setup(for: environment, config: configuration)
    }

    private mutating func setupRepositories() async {
        // ë¦¬í¬ì§€í† ë¦¬ëŠ” ì¸í”„ë¼ì— ì˜ì¡´
        repositoryFactory.setup()
    }

    private mutating func setupUseCases() async {
        // UseCaseëŠ” ë¦¬í¬ì§€í† ë¦¬ì— ì˜ì¡´
        useCaseFactory.setup()
    }

    private mutating func setupServices() async {
        // ì„œë¹„ìŠ¤ëŠ” Use Caseì— ì˜ì¡´
        serviceFactory.setup()
    }

    private mutating func setupPresentation() async {
        // í”„ë ˆì  í…Œì´ì…˜ì€ ì„œë¹„ìŠ¤ì— ì˜ì¡´
        presentationFactory.setup()
    }

    func getAllModules() -> [Module] {
        var allModules: [Module] = []

        // ì˜ì¡´ì„± ìˆœì„œëŒ€ë¡œ ëª¨ë“ˆ ì¶”ê°€
        allModules.append(contentsOf: infrastructureFactory.makeAllModules())
        allModules.append(contentsOf: repositoryFactory.makeAllModules())
        allModules.append(contentsOf: useCaseFactory.makeAllModules())
        allModules.append(contentsOf: serviceFactory.makeAllModules())
        allModules.append(contentsOf: presentationFactory.makeAllModules())

        return allModules
    }

    func getModulesStatistics() -> ModuleStatistics {
        return ModuleStatistics(
            infrastructureCount: infrastructureFactory.makeAllModules().count,
            repositoryCount: repositoryFactory.makeAllModules().count,
            useCaseCount: useCaseFactory.makeAllModules().count,
            serviceCount: serviceFactory.makeAllModules().count,
            presentationCount: presentationFactory.makeAllModules().count
        )
    }
}

struct ModuleStatistics {
    let infrastructureCount: Int
    let repositoryCount: Int
    let useCaseCount: Int
    let serviceCount: Int
    let presentationCount: Int

    var totalCount: Int {
        infrastructureCount + repositoryCount + useCaseCount + serviceCount + presentationCount
    }
}
```

### 2. ë¦¬í¬ì§€í† ë¦¬ ì˜ì¡´ì„±ì„ ê°€ì§„ UseCase íŒ©í† ë¦¬

ìë™ ì˜ì¡´ì„± ì£¼ì…ì„ ìœ„í•œ ë‚´ì¥ UseCase-Repository íŒ¨í„´ í™œìš©:

```swift
struct UseCaseModuleFactory: ModuleFactory {
    var registerModule = RegisterModule()
    var definitions: [@Sendable () -> Module] = []

    mutating func setup() {
        // ë¦¬í¬ì§€í† ë¦¬ ì˜ì¡´ì„±ì„ ê°€ì§„ ì¸ì¦ UseCase
        definitions.append(
            registerModule.makeUseCaseWithRepository(
                LoginUseCase.self,
                repositoryProtocol: AuthRepository.self,
                repositoryFallback: DefaultAuthRepository(),
                factory: { repository in
                    LoginUseCaseImpl(
                        repository: repository,
                        validator: AuthValidator(),
                        logger: WeaveDI.Container.shared.resolve(Logger.self)
                    )
                }
            )
        )

        // ì‚¬ìš©ì ê´€ë¦¬ UseCase
        definitions.append(
            registerModule.makeUseCaseWithRepository(
                UserProfileUseCase.self,
                repositoryProtocol: UserRepository.self,
                repositoryFallback: DefaultUserRepository(),
                factory: { repository in
                    UserProfileUseCaseImpl(
                        repository: repository,
                        imageService: WeaveDI.Container.shared.resolve(ImageService.self)!,
                        analyticsService: WeaveDI.Container.shared.resolve(AnalyticsService.self)
                    )
                }
            )
        )

        // ì—¬ëŸ¬ ë¦¬í¬ì§€í† ë¦¬ë¥¼ ê°€ì§„ ì£¼ë¬¸ ê´€ë¦¬ UseCase
        definitions.append(
            registerModule.makeUseCaseWithRepository(
                OrderManagementUseCase.self,
                repositoryProtocol: OrderRepository.self,
                repositoryFallback: DefaultOrderRepository(),
                factory: { orderRepository in
                    OrderManagementUseCaseImpl(
                        orderRepository: orderRepository,
                        userRepository: WeaveDI.Container.shared.resolve(UserRepository.self)!,
                        paymentRepository: WeaveDI.Container.shared.resolve(PaymentRepository.self)!,
                        notificationService: WeaveDI.Container.shared.resolve(NotificationService.self)
                    )
                }
            )
        )

        // ìºì‹±ì´ ìˆëŠ” ê²€ìƒ‰ UseCase
        definitions.append {
            registerModule.makeModule(SearchUseCase.self) {
                CachedSearchUseCaseImpl(
                    searchRepository: WeaveDI.Container.shared.resolve(SearchRepository.self)!,
                    cacheService: WeaveDI.Container.shared.resolve(CacheService.self)!,
                    analyticsService: WeaveDI.Container.shared.resolve(AnalyticsService.self)
                )
            }
        }
    }

    func makeAllModules() -> [Module] {
        definitions.map { $0() }
    }
}
```

### 3. íŠ¹í™”ëœ íŒ©í† ë¦¬ íƒ€ì…

WeaveDIëŠ” ì¼ë°˜ì ì¸ íŒ¨í„´ì„ ìœ„í•œ ì‚¬ì „ êµ¬ì¶•ëœ íŒ©í† ë¦¬ íƒ€ì…ì„ ì œê³µ:

```swift
// ë‚´ì¥ íŠ¹í™” íŒ©í† ë¦¬ë“¤
public struct RepositoryModuleFactory: ModuleFactory, Sendable {
    // ë°ì´í„° ë ˆì´ì–´ ì˜ì¡´ì„±ì— ìµœì í™”
    // - ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
    // - API í´ë¼ì´ì–¸íŠ¸
    // - ë°ì´í„° ë§¤í¼
    // - ìºì‹± ë ˆì´ì–´
}

public struct UseCaseModuleFactory: ModuleFactory, Sendable {
    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ìµœì í™”
    // - ë„ë©”ì¸ Use Case
    // - ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
    // - ì›Œí¬í”Œë¡œ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜
    // - íš¡ë‹¨ ê´€ì‹¬ì‚¬
}

public struct ScopeModuleFactory: ModuleFactory, Sendable {
    // ìŠ¤ì½”í”„ê°€ ìˆëŠ” ì˜ì¡´ì„±ì— ìµœì í™”
    // - ìš”ì²­ ìŠ¤ì½”í”„ ì„œë¹„ìŠ¤
    // - ì„¸ì…˜ ìŠ¤ì½”í”„ ë°ì´í„°
    // - ì‚¬ìš©ì ìŠ¤ì½”í”„ ì„¤ì •
    // - ì„ì‹œ ì»¨í…ìŠ¤íŠ¸
}
```

#### ì‚¬ìš©ì ì •ì˜ íŠ¹í™” íŒ©í† ë¦¬

```swift
// ì¸í”„ë¼ íŒ©í† ë¦¬
struct InfrastructureModuleFactory: ModuleFactory {
    var registerModule = RegisterModule()
    var definitions: [@Sendable () -> Module] = []

    mutating func setup(for environment: Environment, config: AppConfiguration) {
        // ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
        definitions.append {
            registerModule.makeModule(DatabaseService.self) {
                switch environment {
                case .development:
                    return InMemoryDatabaseService()
                case .staging:
                    return SQLiteDatabaseService(path: config.stagingDBPath)
                case .production:
                    return PostgreSQLDatabaseService(config: config.productionDBConfig)
                }
            }
        }

        // ë„¤íŠ¸ì›Œí¬ ì„¤ì •
        definitions.append {
            registerModule.makeModule(NetworkService.self) {
                HTTPNetworkService(
                    baseURL: config.apiBaseURL,
                    timeout: config.networkTimeout,
                    interceptors: createInterceptors(for: environment)
                )
            }
        }

        // ë¡œê¹… ì„¤ì •
        definitions.append {
            registerModule.makeModule(Logger.self) {
                switch environment {
                case .development:
                    return ConsoleLogger(level: .debug)
                case .staging:
                    return FileLogger(level: .info, path: config.logPath)
                case .production:
                    return RemoteLogger(level: .error, endpoint: config.logEndpoint)
                }
            }
        }
    }

    private func createInterceptors(for environment: Environment) -> [NetworkInterceptor] {
        var interceptors: [NetworkInterceptor] = []

        // ì¸ì¦ ì¸í„°ì…‰í„° ì¶”ê°€
        interceptors.append(AuthInterceptor())

        // ë¹„í”„ë¡œë•ì…˜ì—ì„œ ë¡œê¹… ì¶”ê°€
        if environment != .production {
            interceptors.append(LoggingInterceptor())
        }

        // ì¬ì‹œë„ ì¸í„°ì…‰í„° ì¶”ê°€
        interceptors.append(RetryInterceptor(maxRetries: 3))

        return interceptors
    }

    func makeAllModules() -> [Module] {
        definitions.map { $0() }
    }
}
```

### 4. ModuleFactoryManager - ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ê´€ë¦¬

ëª¨ë‹ˆí„°ë§ê³¼ ê²€ì¦ì„ í¬í•¨í•œ ëª¨ë“  íŒ©í† ë¦¬ì˜ ì¤‘ì•™í™”ëœ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ê´€ë¦¬:

```swift
public struct ModuleFactoryManager: Sendable {
    public var repositoryFactory: RepositoryModuleFactory
    public var useCaseFactory: UseCaseModuleFactory
    public var scopeFactory: ScopeModuleFactory
    public var infrastructureFactory: InfrastructureModuleFactory
    public var presentationFactory: PresentationModuleFactory

    private let logger: Logger?
    private let environment: Environment
    private let configuration: AppConfiguration

    public init(
        environment: Environment,
        configuration: AppConfiguration,
        logger: Logger? = nil
    ) {
        self.environment = environment
        self.configuration = configuration
        self.logger = logger

        // í™˜ê²½ ì»¨í…ìŠ¤íŠ¸ë¡œ íŒ©í† ë¦¬ ì´ˆê¸°í™”
        self.repositoryFactory = RepositoryModuleFactory()
        self.useCaseFactory = UseCaseModuleFactory()
        self.scopeFactory = ScopeModuleFactory()
        self.infrastructureFactory = InfrastructureModuleFactory()
        self.presentationFactory = PresentationModuleFactory()
    }

    public mutating func setupAllFactories() async {
        logger?.info("ğŸ­ \(environment) í™˜ê²½ì„ ìœ„í•œ ëª¨ë“ˆ íŒ©í† ë¦¬ ì„¤ì • ì¤‘")

        // ì˜ì¡´ì„± ìˆœì„œëŒ€ë¡œ ì„¤ì •
        infrastructureFactory.setup(for: environment, config: configuration)
        repositoryFactory.setup()
        useCaseFactory.setup()
        scopeFactory.setup()
        presentationFactory.setup()

        logger?.info("âœ… ëª¨ë“  íŒ©í† ë¦¬ê°€ êµ¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤")
    }

    public func registerAll() async throws {
        logger?.info("ğŸ“¦ ëª¨ë“ˆ ë“±ë¡ í”„ë¡œì„¸ìŠ¤ ì‹œì‘")

        // ëª¨ë“  ëª¨ë“ˆ ê°€ì ¸ì˜¤ê¸°
        let allModules = getAllModulesInOrder()

        logger?.info("ğŸ“Š ë“±ë¡í•  \(allModules.count)ê°œ ëª¨ë“ˆì„ ì°¾ì•˜ìŠµë‹ˆë‹¤")

        // ë“±ë¡ ì „ ëª¨ë“ˆ ê²€ì¦
        try validateModules(allModules)

        // ì„±ëŠ¥ í–¥ìƒì„ ìœ„í•´ ë°°ì¹˜ë¡œ ëª¨ë“ˆ ë“±ë¡
        await registerModulesInBatches(allModules)

        logger?.info("ğŸ‰ ëª¨ë“ˆ ë“±ë¡ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
    }

    private func getAllModulesInOrder() -> [Module] {
        var allModules: [Module] = []

        // ì˜ì¡´ì„± ìˆœì„œëŒ€ë¡œ ë“±ë¡
        allModules.append(contentsOf: infrastructureFactory.makeAllModules())
        allModules.append(contentsOf: repositoryFactory.makeAllModules())
        allModules.append(contentsOf: useCaseFactory.makeAllModules())
        allModules.append(contentsOf: scopeFactory.makeAllModules())
        allModules.append(contentsOf: presentationFactory.makeAllModules())

        return allModules
    }

    private func validateModules(_ modules: [Module]) throws {
        guard !modules.isEmpty else {
            throw ModuleFactoryError.noModulesFound
        }

        // ì¤‘ë³µ ë“±ë¡ í™•ì¸
        var typeNames: Set<String> = []
        for module in modules {
            let typeName = String(describing: module.type)
            if typeNames.contains(typeName) {
                throw ModuleFactoryError.duplicateModule(typeName)
            }
            typeNames.insert(typeName)
        }

        logger?.info("âœ… ëª¨ë“ˆ ê²€ì¦ í†µê³¼")
    }

    private func registerModulesInBatches(_ modules: [Module]) async {
        let batchSize = 10 // í•œ ë²ˆì— 10ê°œ ëª¨ë“ˆ ë“±ë¡
        let batches = modules.chunked(into: batchSize)

        for (index, batch) in batches.enumerated() {
            logger?.info("ğŸ“¦ ë°°ì¹˜ \(index + 1)/\(batches.count) ë“±ë¡ ì¤‘")

            await withTaskGroup(of: Void.self) { group in
                for module in batch {
                    group.addTask {
                        await WeaveDI.Container.shared.register(module)
                        self.logger?.debug("âœ… ë“±ë¡ë¨: \(module.description)")
                    }
                }
            }
        }
    }

    public func getRegistrationStatistics() -> RegistrationStatistics {
        return RegistrationStatistics(
            infrastructureModules: infrastructureFactory.makeAllModules().count,
            repositoryModules: repositoryFactory.makeAllModules().count,
            useCaseModules: useCaseFactory.makeAllModules().count,
            scopeModules: scopeFactory.makeAllModules().count,
            presentationModules: presentationFactory.makeAllModules().count
        )
    }
}

// ì§€ì› íƒ€ì…
enum ModuleFactoryError: LocalizedError {
    case noModulesFound
    case duplicateModule(String)
    case invalidConfiguration

    var errorDescription: String? {
        switch self {
        case .noModulesFound:
            return "ì–´ë–¤ íŒ©í† ë¦¬ì—ì„œë„ ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
        case .duplicateModule(let typeName):
            return "íƒ€ì… \(typeName)ì— ëŒ€í•œ ì¤‘ë³µ ëª¨ë“ˆ ë“±ë¡"
        case .invalidConfiguration:
            return "ìœ íš¨í•˜ì§€ ì•Šì€ íŒ©í† ë¦¬ êµ¬ì„±"
        }
    }
}

struct RegistrationStatistics {
    let infrastructureModules: Int
    let repositoryModules: Int
    let useCaseModules: Int
    let scopeModules: Int
    let presentationModules: Int

    var totalModules: Int {
        infrastructureModules + repositoryModules + useCaseModules + scopeModules + presentationModules
    }
}

// ì‚¬ìš©ë²•
func setupApplication() async throws {
    var manager = ModuleFactoryManager(
        environment: .production,
        configuration: AppConfiguration.load(),
        logger: ConsoleLogger()
    )

    await manager.setupAllFactories()
    try await manager.registerAll()

    let stats = manager.getRegistrationStatistics()
    print("ğŸ¯ \(5)ê°œ íŒ©í† ë¦¬ì— ê±¸ì³ \(stats.totalModules)ê°œ ëª¨ë“ˆì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤")
}
```

## ì‹¤ì œ êµ¬í˜„ ì‚¬ë¡€

### ëŒ€ê·œëª¨ ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •

#### í¬ê´„ì  ëª¨ë“ˆ ì‹œìŠ¤í…œì„ ê°€ì§„ SwiftUI ì• í”Œë¦¬ì¼€ì´ì…˜

```swift
@main
struct EnterpriseWeaveDIApp: App {
    @State private var isInitialized = false
    @State private var initializationError: Error?

    init() {
        // ì´ˆê¸°í™”ë¥¼ ì‹œì‘í•˜ë˜ ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ ì°¨ë‹¨í•˜ì§€ ì•ŠìŒ
        Task {
            await initializeApplication()
        }
    }

    var body: some Scene {
        WindowGroup {
            if isInitialized {
                ContentView()
            } else if let error = initializationError {
                ErrorView(error: error) {
                    Task {
                        await retryInitialization()
                    }
                }
            } else {
                LoadingView()
                    .task {
                        await initializeApplication()
                    }
            }
        }
    }

    @MainActor
    private func initializeApplication() async {
        do {
            let startTime = Date()
            print("ğŸš€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™” ì‹œì‘...")

            // ëª¨ë“ˆ íŒ©í† ë¦¬ ë§¤ë‹ˆì € ì„¤ì •
            var manager = ModuleFactoryManager(
                environment: AppEnvironment.current,
                configuration: try AppConfiguration.load(),
                logger: AppLogger.shared
            )

            // ëª¨ë“  íŒ©í† ë¦¬ ì„¤ì •
            await manager.setupAllFactories()

            // ëª¨ë“  ëª¨ë“ˆ ë“±ë¡
            try await manager.registerAll()

            // ì¤‘ìš”í•œ ì˜ì¡´ì„± ê²€ì¦
            try await verifyCriticalDependencies()

            let initTime = Date().timeIntervalSince(startTime)
            print("âœ… ì• í”Œë¦¬ì¼€ì´ì…˜ì´ \(String(format: "%.2f", initTime))ì´ˆì— ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤")

            // í†µê³„ í‘œì‹œ
            let stats = manager.getRegistrationStatistics()
            print("ğŸ“Š ë“±ë¡ëœ ëª¨ë“ˆ: \(stats.totalModules)")

            isInitialized = true

        } catch {
            print("âŒ ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™” ì‹¤íŒ¨: \(error)")
            initializationError = error
        }
    }

    private func retryInitialization() async {
        initializationError = nil
        await initializeApplication()
    }

    private func verifyCriticalDependencies() async throws {
        // í•„ìˆ˜ ì„œë¹„ìŠ¤ê°€ ì‚¬ìš© ê°€ëŠ¥í•œì§€ ê²€ì¦
        let criticalServices: [Any.Type] = [
            DatabaseService.self,
            NetworkService.self,
            Logger.self,
            UserRepository.self,
            AuthenticationService.self
        ]

        for serviceType in criticalServices {
            let resolved = WeaveDI.Container.shared.resolve(serviceType)
            guard resolved != nil else {
                throw InitializationError.criticalServiceMissing(String(describing: serviceType))
            }
        }

        print("âœ… ëª¨ë“  ì¤‘ìš”í•œ ì˜ì¡´ì„±ì´ ê²€ì¦ë˜ì—ˆìŠµë‹ˆë‹¤")
    }
}

enum InitializationError: LocalizedError {
    case criticalServiceMissing(String)
    case configurationLoadFailed
    case moduleRegistrationFailed(String)

    var errorDescription: String? {
        switch self {
        case .criticalServiceMissing(let service):
            return "ì¤‘ìš”í•œ ì„œë¹„ìŠ¤ê°€ ëˆ„ë½ë¨: \(service)"
        case .configurationLoadFailed:
            return "ì• í”Œë¦¬ì¼€ì´ì…˜ êµ¬ì„± ë¡œë“œ ì‹¤íŒ¨"
        case .moduleRegistrationFailed(let details):
            return "ëª¨ë“ˆ ë“±ë¡ ì‹¤íŒ¨: \(details)"
        }
    }
}
```

#### íŒ©í† ë¦¬ ì‹œìŠ¤í…œì„ ê°€ì§„ UIKit ì• í”Œë¦¬ì¼€ì´ì…˜

```swift
class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    var window: UIWindow?
    private var moduleManager: ModuleFactoryManager?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        guard let windowScene = (scene as? UIWindowScene) else { return }

        // ìœˆë„ìš° ì„¤ì •
        window = UIWindow(windowScene: windowScene)

        // ë¡œë”© í™”ë©´ í‘œì‹œ
        window?.rootViewController = LoadingViewController()
        window?.makeKeyAndVisible()

        // ë¹„ë™ê¸°ë¡œ ì´ˆê¸°í™”
        Task {
            await initializeModuleSystem()
        }
    }

    private func initializeModuleSystem() async {
        do {
            print("ğŸ­ ëª¨ë“ˆ íŒ©í† ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...")

            // ëª¨ë“ˆ ë§¤ë‹ˆì € ìƒì„± ë° ì„¤ì •
            var manager = ModuleFactoryManager(
                environment: AppEnvironment.current,
                configuration: try AppConfiguration.load(),
                logger: AppLogger.shared
            )
            self.moduleManager = manager

            // íŒ©í† ë¦¬ ì„¤ì •
            await manager.setupAllFactories()

            // ëª¨ë“  ëª¨ë“ˆ ë“±ë¡
            try await manager.registerAll()

            // ë©”ì¸ ì•±ìœ¼ë¡œ ì „í™˜
            await transitionToMainApp()

        } catch {
            await showInitializationError(error)
        }
    }

    @MainActor
    private func transitionToMainApp() {
        // ì£¼ì…ëœ ì˜ì¡´ì„±ìœ¼ë¡œ ë©”ì¸ ì½”ë””ë„¤ì´í„° ìƒì„±
        let mainCoordinator = MainCoordinator()
        let mainViewController = mainCoordinator.start()

        // ë¶€ë“œëŸ¬ìš´ ì „í™˜
        UIView.transition(with: window!, duration: 0.3, options: .transitionCrossDissolve) {
            self.window?.rootViewController = mainViewController
        }

        print("ğŸ‰ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ ì„±ê³µì ìœ¼ë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤")
    }

    @MainActor
    private func showInitializationError(_ error: Error) {
        let errorViewController = ErrorViewController(error: error) { [weak self] in
            Task {
                await self?.initializeModuleSystem()
            }
        }

        window?.rootViewController = errorViewController
    }
}
```

### í™˜ê²½ë³„ íŒ©í† ë¦¬

í¬ê´„ì ì¸ í™˜ê²½ ì¸ì‹ íŒ©í† ë¦¬ ì‹œìŠ¤í…œ:

```swift
struct EnvironmentModuleFactory: ModuleFactory {
    var registerModule = RegisterModule()
    var definitions: [@Sendable () -> Module] = []
    let environment: Environment
    let configuration: AppConfiguration

    init(environment: Environment, configuration: AppConfiguration) {
        self.environment = environment
        self.configuration = configuration
    }

    mutating func setup() {
        switch environment {
        case .development:
            setupDevelopmentModules()
        case .staging:
            setupStagingModules()
        case .production:
            setupProductionModules()
        case .testing:
            setupTestingModules()
        }
    }

    private mutating func setupDevelopmentModules() {
        print("ğŸ› ï¸ ê°œë°œ ëª¨ë“ˆ ì„¤ì • ì¤‘")

        // ìì„¸í•œ ë¡œê¹…ì´ ìˆëŠ” ëª© API
        definitions.append {
            registerModule.makeModule(APIClient.self) {
                MockAPIClient(
                    baseURL: "https://dev-api.example.com",
                    enableNetworkLogs: true,
                    simulateLatency: true,
                    failureRate: 0.1 // í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ 10% ì‹¤íŒ¨ìœ¨
                )
            }
        }

        // ë””ë²„ê¹…ì„ ìœ„í•œ ìƒì„¸ ë¡œê¹…
        definitions.append {
            registerModule.makeModule(Logger.self) {
                CompositeLogger([
                    ConsoleLogger(level: .debug),
                    FileLogger(level: .info, path: configuration.devLogPath),
                    OSLogger(subsystem: "com.app.dev", category: "general")
                ])
            }
        }

        // ë¹ ë¥¸ ê°œë°œì„ ìœ„í•œ ì¸ë©”ëª¨ë¦¬ ë°ì´í„°ë² ì´ìŠ¤
        definitions.append {
            registerModule.makeModule(DatabaseService.self) {
                InMemoryDatabaseService(preloadTestData: true)
            }
        }

        // ì½˜ì†”ì— ë¡œê·¸ë¥¼ ë‚¨ê¸°ëŠ” ëª© ë¶„ì„
        definitions.append {
            registerModule.makeModule(AnalyticsService.self) {
                ConsoleAnalyticsService(verbose: true)
            }
        }

        // ìºì‹±ì´ ë¹„í™œì„±í™”ëœ ë””ë²„ê·¸ ì´ë¯¸ì§€ ë¡œë”
        definitions.append {
            registerModule.makeModule(ImageLoader.self) {
                DebugImageLoader(cacheEnabled: false)
            }
        }
    }

    private mutating func setupStagingModules() {
        print("ğŸ­ ìŠ¤í…Œì´ì§• ëª¨ë“ˆ ì„¤ì • ì¤‘")

        // ìŠ¤í…Œì´ì§• ì—”ë“œí¬ì¸íŠ¸ê°€ ìˆëŠ” ì‹¤ì œ API
        definitions.append {
            registerModule.makeModule(APIClient.self) {
                HTTPAPIClient(
                    baseURL: "https://staging-api.example.com",
                    timeout: 30,
                    retryPolicy: RetryPolicy(maxRetries: 3),
                    certificatePinner: nil, // ìŠ¤í…Œì´ì§•ì—ì„œëŠ” ëœ ì—„ê²©
                    interceptors: [
                        AuthInterceptor(),
                        LoggingInterceptor(level: .info),
                        MetricsInterceptor()
                    ]
                )
            }
        }

        // ì›ê²© ë³´ê³ ë¥¼ í¬í•¨í•œ êµ¬ì¡°í™”ëœ ë¡œê¹…
        definitions.append {
            registerModule.makeModule(Logger.self) {
                CompositeLogger([
                    ConsoleLogger(level: .info),
                    RemoteLogger(
                        endpoint: "https://logs-staging.example.com",
                        level: .warning
                    )
                ])
            }
        }

        // ìŠ¤í…Œì´ì§• ë°ì´í„°ê°€ ìˆëŠ” ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤
        definitions.append {
            registerModule.makeModule(DatabaseService.self) {
                PostgreSQLDatabaseService(
                    connectionString: configuration.stagingDBConnectionString,
                    poolSize: 5,
                    enableMigrations: true
                )
            }
        }

        // í…ŒìŠ¤íŠ¸ ë¶„ì„ ì„œë¹„ìŠ¤
        definitions.append {
            registerModule.makeModule(AnalyticsService.self) {
                TestAnalyticsService(
                    endpoint: "https://analytics-staging.example.com",
                    flushInterval: 10 // ì´ˆ
                )
            }
        }
    }

    private mutating func setupProductionModules() {
        print("ğŸš€ í”„ë¡œë•ì…˜ ëª¨ë“ˆ ì„¤ì • ì¤‘")

        // ëª¨ë“  ë³´ì•ˆ ì¡°ì¹˜ê°€ í¬í•¨ëœ í”„ë¡œë•ì…˜ API
        definitions.append {
            registerModule.makeModule(APIClient.self) {
                SecureHTTPAPIClient(
                    baseURL: "https://api.example.com",
                    timeout: 15,
                    retryPolicy: RetryPolicy(maxRetries: 2),
                    certificatePinner: SSLCertificatePinner(
                        certificates: configuration.trustedCertificates
                    ),
                    interceptors: [
                        AuthInterceptor(),
                        RateLimitInterceptor(),
                        SecurityHeadersInterceptor(),
                        MetricsInterceptor()
                    ]
                )
            }
        }

        // í”„ë¡œë•ì…˜ ë¡œê¹… - ì˜¤ë¥˜ë§Œ
        definitions.append {
            registerModule.makeModule(Logger.self) {
                ProductionLogger(
                    remoteEndpoint: "https://logs.example.com",
                    level: .error,
                    encryptionKey: configuration.logEncryptionKey
                )
            }
        }

        // ì»¤ë„¥ì…˜ í’€ë§ì´ ìˆëŠ” í”„ë¡œë•ì…˜ ë°ì´í„°ë² ì´ìŠ¤
        definitions.append {
            registerModule.makeModule(DatabaseService.self) {
                ProductionDatabaseService(
                    primaryConnectionString: configuration.primaryDBConnectionString,
                    readReplicaConnectionString: configuration.readReplicaConnectionString,
                    poolSize: 20,
                    enableConnectionPooling: true,
                    enableReadWriteSplit: true
                )
            }
        }

        // ê°œì¸ì •ë³´ ë³´í˜¸ ê·œì • ì¤€ìˆ˜ê°€ ìˆëŠ” ì „ì²´ ë¶„ì„
        definitions.append {
            registerModule.makeModule(AnalyticsService.self) {
                PrivacyCompliantAnalyticsService(
                    providers: [
                        FirebaseAnalyticsProvider(),
                        MixpanelAnalyticsProvider(),
                        CustomAnalyticsProvider(endpoint: configuration.analyticsEndpoint)
                    ],
                    privacySettings: configuration.privacySettings
                )
            }
        }

        // ì„±ëŠ¥ ìµœì í™”ëœ ì´ë¯¸ì§€ ë¡œë”
        definitions.append {
            registerModule.makeModule(ImageLoader.self) {
                OptimizedImageLoader(
                    cacheSize: 100_000_000, // 100MB
                    compressionQuality: 0.8,
                    enableWebP: true
                )
            }
        }
    }

    private mutating func setupTestingModules() {
        print("ğŸ§ª í…ŒìŠ¤íŒ… ëª¨ë“ˆ ì„¤ì • ì¤‘")

        // í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ê²°ì •ë¡ ì  ëª© ì„œë¹„ìŠ¤
        definitions.append {
            registerModule.makeModule(APIClient.self) {
                DeterministicMockAPIClient()
            }
        }

        definitions.append {
            registerModule.makeModule(Logger.self) {
                SilentLogger() // í…ŒìŠ¤íŠ¸ ì¤‘ ì¶œë ¥ ì—†ìŒ
            }
        }

        definitions.append {
            registerModule.makeModule(DatabaseService.self) {
                InMemoryDatabaseService(preloadTestData: false)
            }
        }
    }

    func makeAllModules() -> [Module] {
        definitions.map { $0() }
    }
}

// ì§€ì› êµ¬ì„±
struct AppConfiguration {
    let devLogPath: String
    let stagingDBConnectionString: String
    let primaryDBConnectionString: String
    let readReplicaConnectionString: String
    let trustedCertificates: [Certificate]
    let logEncryptionKey: String
    let analyticsEndpoint: String
    let privacySettings: PrivacySettings

    static func load() throws -> AppConfiguration {
        // ë²ˆë“¤, í™˜ê²½ ë³€ìˆ˜ ë˜ëŠ” ì›ê²© êµ¬ì„±ì—ì„œ ë¡œë“œ
        // êµ¬í˜„ì€ ì•±ì˜ êµ¬ì„± ì „ëµì— ë”°ë¼ ë‹¤ë¦„
        fatalError("êµ¬ì„± ë¡œë”© êµ¬í˜„")
    }
}
```

### ë¹„ë™ê¸° ëª¨ë“ˆ íŒ©í† ë¦¬

ë³µì¡í•œ ì´ˆê¸°í™” ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ìœ„í•œ ê³ ê¸‰ ë¹„ë™ê¸° ëª¨ë“ˆ íŒ©í† ë¦¬:

```swift
struct AsyncModuleFactory {
    private let logger: Logger?
    private let configuration: AppConfiguration
    private let timeout: TimeInterval

    init(configuration: AppConfiguration, logger: Logger? = nil, timeout: TimeInterval = 30) {
        self.configuration = configuration
        self.logger = logger
        self.timeout = timeout
    }

    func makeConfigurationModule() async throws -> Module {
        logger?.info("ğŸ”§ ì›ê²© êµ¬ì„± ë¡œë”© ì¤‘...")

        do {
            // íƒ€ì„ì•„ì›ƒê³¼ í•¨ê»˜ ì›ê²© êµ¬ì„± ê°€ì ¸ì˜¤ê¸°
            let remoteConfig = try await withTimeout(timeout) {
                try await RemoteConfigService.fetchConfiguration(
                    endpoint: configuration.configEndpoint,
                    apiKey: configuration.configAPIKey
                )
            }

            logger?.info("âœ… ì›ê²© êµ¬ì„±ì´ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤")

            return Module(RemoteConfiguration.self) {
                remoteConfig
            }
        } catch {
            logger?.warning("âš ï¸ ì›ê²© êµ¬ì„± ë¡œë“œ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©: \(error)")

            // ë¡œì»¬ êµ¬ì„±ìœ¼ë¡œ í´ë°±
            return Module(RemoteConfiguration.self) {
                RemoteConfiguration.defaultConfiguration()
            }
        }
    }

    func makeDatabaseModule() async throws -> Module {
        logger?.info("ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì´ˆê¸°í™” ì¤‘...")

        do {
            // ì¬ì‹œë„ ë¡œì§ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
            let database = try await withRetry(maxAttempts: 3, delay: 1.0) {
                try await DatabaseManager.initialize(
                    connectionString: configuration.primaryDBConnectionString,
                    poolSize: 10,
                    enableSSL: true
                )
            }

            // ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ê²€ì¦
            try await database.healthCheck()

            logger?.info("âœ… ë°ì´í„°ë² ì´ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ê³  ì •ìƒì…ë‹ˆë‹¤")

            return Module(DatabaseService.self) {
                database
            }
        } catch {
            logger?.error("âŒ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨: \(error)")
            throw AsyncModuleError.databaseInitializationFailed(error)
        }
    }

    func makeAuthenticationModule() async throws -> Module {
        logger?.info("ğŸ” ì¸ì¦ ì„œë¹„ìŠ¤ ì„¤ì • ì¤‘...")

        // ì¸ì¦ êµ¬ì„± ë¡œë“œ
        let authConfig = try await AuthConfiguration.load()

        // ì¸ì¦ ê³µê¸‰ì ì´ˆê¸°í™”
        let providers = try await initializeAuthProviders(authConfig)

        logger?.info("âœ… \(providers.count)ê°œ ê³µê¸‰ìë¡œ ì¸ì¦ ì„œë¹„ìŠ¤ê°€ êµ¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤")

        return Module(AuthenticationService.self) {
            MultiProviderAuthenticationService(
                providers: providers,
                defaultProvider: authConfig.defaultProvider
            )
        }
    }

    func makeAnalyticsModule() async throws -> Module {
        logger?.info("ğŸ“Š ë¶„ì„ ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ì¤‘...")

        // ë¶„ì„ì— ëŒ€í•œ ì‚¬ìš©ì ë™ì˜ ì–»ê¸°
        let consentStatus = await AnalyticsConsentManager.getConsentStatus()

        guard consentStatus.analyticsAllowed else {
            logger?.info("ğŸ“Š ì‚¬ìš©ì ë™ì˜ë¡œ ì¸í•´ ë¶„ì„ì´ ë¹„í™œì„±í™”ë¨")
            return Module(AnalyticsService.self) {
                NoOpAnalyticsService()
            }
        }

        // ë™ì˜ì™€ í•¨ê»˜ ë¶„ì„ ì´ˆê¸°í™”
        let analyticsService = try await AnalyticsService.initialize(
            configuration: configuration.analyticsConfig,
            consentSettings: consentStatus
        )

        logger?.info("âœ… ë¶„ì„ ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤")

        return Module(AnalyticsService.self) {
            analyticsService
        }
    }

    private func initializeAuthProviders(_ config: AuthConfiguration) async throws -> [AuthProvider] {
        var providers: [AuthProvider] = []

        // OAuth ê³µê¸‰ìë¥¼ ë™ì‹œì— ì´ˆê¸°í™”
        await withTaskGroup(of: AuthProvider?.self) { group in
            for providerConfig in config.providers {
                group.addTask {
                    do {
                        return try await AuthProviderFactory.create(providerConfig)
                    } catch {
                        self.logger?.error("ì¸ì¦ ê³µê¸‰ì \(providerConfig.type) ì´ˆê¸°í™” ì‹¤íŒ¨: \(error)")
                        return nil
                    }
                }
            }

            for await provider in group {
                if let provider = provider {
                    providers.append(provider)
                }
            }
        }

        guard !providers.isEmpty else {
            throw AsyncModuleError.noAuthProvidersAvailable
        }

        return providers
    }

    // ë°°ì¹˜ ë¹„ë™ê¸° ëª¨ë“ˆ ìƒì„±
    func makeAllAsyncModules() async throws -> [Module] {
        logger?.info("âš¡ ëª¨ë“  ë¹„ë™ê¸° ëª¨ë“ˆì„ ë™ì‹œì— ìƒì„± ì¤‘...")

        return try await withThrowingTaskGroup(of: Module.self) { group in
            // ëª¨ë“  ë¹„ë™ê¸° ëª¨ë“ˆ ìƒì„± ì‘ì—… ì¶”ê°€
            group.addTask { try await self.makeConfigurationModule() }
            group.addTask { try await self.makeDatabaseModule() }
            group.addTask { try await self.makeAuthenticationModule() }
            group.addTask { try await self.makeAnalyticsModule() }

            var modules: [Module] = []
            for try await module in group {
                modules.append(module)
            }
            return modules
        }
    }
}

// ì˜¤ë¥˜ íƒ€ì…
enum AsyncModuleError: LocalizedError {
    case databaseInitializationFailed(Error)
    case configurationLoadFailed(Error)
    case noAuthProvidersAvailable
    case timeoutExceeded

    var errorDescription: String? {
        switch self {
        case .databaseInitializationFailed(let error):
            return "ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨: \(error.localizedDescription)"
        case .configurationLoadFailed(let error):
            return "êµ¬ì„± ë¡œë“œ ì‹¤íŒ¨: \(error.localizedDescription)"
        case .noAuthProvidersAvailable:
            return "ì´ˆê¸°í™”í•  ìˆ˜ ìˆëŠ” ì¸ì¦ ê³µê¸‰ìê°€ ì—†ìŠµë‹ˆë‹¤"
        case .timeoutExceeded:
            return "ë¹„ë™ê¸° ëª¨ë“ˆ ì´ˆê¸°í™” ì‹œê°„ ì´ˆê³¼"
        }
    }
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
func withTimeout<T>(_ timeout: TimeInterval, operation: @escaping () async throws -> T) async throws -> T {
    try await withThrowingTaskGroup(of: T.self) { group in
        group.addTask {
            try await operation()
        }

        group.addTask {
            try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
            throw AsyncModuleError.timeoutExceeded
        }

        guard let result = try await group.next() else {
            throw AsyncModuleError.timeoutExceeded
        }

        group.cancelAll()
        return result
    }
}

func withRetry<T>(maxAttempts: Int, delay: TimeInterval, operation: @escaping () async throws -> T) async throws -> T {
    var lastError: Error?

    for attempt in 1...maxAttempts {
        do {
            return try await operation()
        } catch {
            lastError = error
            if attempt < maxAttempts {
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            }
        }
    }

    throw lastError ?? AsyncModuleError.timeoutExceeded
}

// ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œì˜ ì‚¬ìš©
func setupAsyncModules() async throws {
    let asyncFactory = AsyncModuleFactory(
        configuration: AppConfiguration.load(),
        logger: AppLogger.shared
    )

    await WeaveDI.Container.bootstrap { container in
        // ë¨¼ì € ë™ê¸° ëª¨ë“ˆ ë“±ë¡
        var syncFactory = ApplicationModuleFactory()
        await syncFactory.setupAll()

        for module in syncFactory.getAllModules() {
            await container.register(module)
        }

        // ê·¸ ë‹¤ìŒ ë¹„ë™ê¸° ëª¨ë“ˆ ë“±ë¡
        do {
            let asyncModules = try await asyncFactory.makeAllAsyncModules()
            for module in asyncModules {
                await container.register(module)
            }
        } catch {
            print("âš ï¸ ì¼ë¶€ ë¹„ë™ê¸° ëª¨ë“ˆ ì´ˆê¸°í™” ì‹¤íŒ¨: \(error)")
            // ë¶€ë¶„ ì´ˆê¸°í™” ë˜ëŠ” í´ë°± ì „ëµ ì²˜ë¦¬
        }
    }
}
```

## ëª¨ë²” ì‚¬ë¡€

### 1. ìˆœì„œëŒ€ë¡œ ëª¨ë“ˆ ë“±ë¡

```swift
struct OrderedModuleRegistration {
    static func registerInOrder() async {
        await WeaveDI.Container.bootstrap { container in
            // 1. ì¸í”„ë¼ ë ˆì´ì–´
            let infraModules = InfrastructureModuleFactory().makeAllModules()
            for module in infraModules {
                await container.register(module)
            }

            // 2. ë°ì´í„° ë ˆì´ì–´
            let dataModules = DataModuleFactory().makeAllModules()
            for module in dataModules {
                await container.register(module)
            }

            // 3. ë„ë©”ì¸ ë ˆì´ì–´
            let domainModules = DomainModuleFactory().makeAllModules()
            for module in domainModules {
                await container.register(module)
            }

            // 4. í”„ë ˆì  í…Œì´ì…˜ ë ˆì´ì–´
            let presentationModules = PresentationModuleFactory().makeAllModules()
            for module in presentationModules {
                await container.register(module)
            }
        }
    }
}
```

### 2. í…ŒìŠ¤íŒ… ì§€ì›

```swift
#if DEBUG
struct TestModuleFactory: ModuleFactory {
    var registerModule = RegisterModule()
    var definitions: [@Sendable () -> Module] = []

    mutating func setupMocks() {
        definitions.append {
            registerModule.makeModule(UserRepository.self) {
                MockUserRepository()
            }
        }

        definitions.append {
            registerModule.makeModule(NetworkService.self) {
                MockNetworkService()
            }
        }
    }

    func makeAllModules() -> [Module] {
        definitions.map { $0() }
    }
}
#endif
```

### 3. ì˜¤ë¥˜ ì²˜ë¦¬

```swift
struct SafeModuleFactory: ModuleFactory {
    var registerModule = RegisterModule()
    var definitions: [@Sendable () -> Module] = []

    mutating func setup() {
        definitions.append {
            registerModule.makeModule(RiskyService.self) {
                do {
                    return try RiskyServiceImpl()
                } catch {
                    print("RiskyService ìƒì„± ì‹¤íŒ¨: \(error)")
                    return FallbackService()
                }
            }
        }
    }

    func makeAllModules() -> [Module] {
        definitions.map { $0() }
    }
}
```

## ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### ì§€ì—° ëª¨ë“ˆ ìƒì„±

```swift
struct LazyModuleFactory {
    private lazy var expensiveModule = Module(ExpensiveService.self) {
        ExpensiveServiceImpl() // ì²˜ìŒ ì ‘ê·¼í•  ë•Œë§Œ ìƒì„±
    }

    func getExpensiveModule() -> Module {
        expensiveModule
    }
}
```

WeaveDIì˜ ëª¨ë“ˆ íŒ©í† ë¦¬ ì‹œìŠ¤í…œì€ ê¹¨ë—í•˜ê³  í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•˜ë©° ìœ ì§€ë³´ìˆ˜ ê°€ëŠ¥í•œ ì½”ë“œ ì•„í‚¤í…ì²˜ë¥¼ ìœ ì§€í•˜ë©´ì„œ ë³µì¡í•œ ì˜ì¡´ì„± ê·¸ë˜í”„ë¥¼ ê´€ë¦¬í•˜ëŠ” ê²¬ê³ í•œ ê¸°ë°˜ì„ ì œê³µí•©ë‹ˆë‹¤.

## DiModuleFactory - ê³µí†µ DI ì˜ì¡´ì„± ê´€ë¦¬ (v3.3.4+)

v3.3.4ë¶€í„° ë„ì…ëœ `DiModuleFactory`ëŠ” Logger, Config, Cache ë“± ì•± ì „ë°˜ì—ì„œ ì‚¬ìš©ë˜ëŠ” ê³µí†µ DI ì˜ì¡´ì„±ì„ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê¸° ìœ„í•œ íŠ¹ë³„í•œ ëª¨ë“ˆ íŒ©í† ë¦¬ì…ë‹ˆë‹¤.

### í•µì‹¬ íŠ¹ì§•

- ğŸ“¦ **ê³µí†µ ì˜ì¡´ì„± ê´€ë¦¬**: ì•± ì „ë°˜ì—ì„œ ê³µìœ ë˜ëŠ” ì˜ì¡´ì„±ì„ ì¤‘ì•™ì§‘ì¤‘ì‹ìœ¼ë¡œ ê´€ë¦¬
- ğŸ”„ **ë¹Œë” íŒ¨í„´**: ì§ê´€ì ì¸ APIë¡œ ì˜ì¡´ì„± ì¶”ê°€
- âš™ï¸ **ìë™ í†µí•©**: ModuleFactoryManagerì™€ seamless ì—°ë™
- ğŸ¯ **íƒ€ì… ì•ˆì „ì„±**: ì»´íŒŒì¼ íƒ€ì„ íƒ€ì… ê²€ì¦

### ê¸°ë³¸ ì‚¬ìš©ë²•

```swift
import WeaveDI

// DiModuleFactory ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
var diFactory = DiModuleFactory()

// ê³µí†µ DI ì˜ì¡´ì„± ì¶”ê°€ (ë¹Œë” íŒ¨í„´)
diFactory.addDependency(Logger.self) {
    ConsoleLogger()
}

diFactory.addDependency(APIConfig.self) {
    APIConfig(baseURL: "https://api.example.com")
}

diFactory.addDependency(CacheService.self) {
    MemoryCacheService()
}

// ì˜ì¡´ì„± ëª¨ë“ˆ ìƒì„±
let modules = diFactory.makeAllModules()
```

### ModuleFactoryManagerì™€ í†µí•©

`DiModuleFactory`ëŠ” `ModuleFactoryManager`ì™€ ì™„ë²½í•˜ê²Œ í†µí•©ë˜ì–´ ë‹¤ë¥¸ íŒ©í† ë¦¬ë“¤ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```swift
// ModuleFactoryManager ì„¤ì •
var factoryManager = ModuleFactoryManager()

// DiModuleFactory ì„¤ì •
factoryManager.diFactory.addDependency(Logger.self) {
    #if DEBUG
    ConsoleLogger()
    #else
    ProductionLogger()
    #endif
}

factoryManager.diFactory.addDependency(NetworkConfig.self) {
    NetworkConfig(
        timeout: 30.0,
        retryCount: 3,
        baseURL: "https://api.example.com"
    )
}

// Repositoryì™€ UseCase íŒ©í† ë¦¬ë„ í•¨ê»˜ ì„¤ì •
factoryManager.repositoryFactory.addRepository(UserRepository.self) {
    UserRepositoryImpl()
}

factoryManager.useCaseFactory.addUseCase(AuthUseCase.self) {
    AuthUseCaseImpl()
}

// ëª¨ë“  ëª¨ë“ˆì„ í•œë²ˆì— ë“±ë¡
await factoryManager.registerAllModules()
```

### í™˜ê²½ë³„ ì˜ì¡´ì„± ì„¤ì •

í™˜ê²½ì— ë”°ë¼ ë‹¤ë¥¸ ì˜ì¡´ì„±ì„ ì„¤ì •í•  ìˆ˜ ìˆëŠ” ìœ ì—°í•œ íŒ¨í„´:

```swift
struct EnvironmentDiFactory {
    static func create(for environment: AppEnvironment) -> DiModuleFactory {
        var factory = DiModuleFactory()

        // ê³µí†µ ì˜ì¡´ì„±
        factory.addDependency(AppConfig.self) {
            AppConfig.load()
        }

        // í™˜ê²½ë³„ Logger
        switch environment {
        case .development:
            factory.addDependency(Logger.self) {
                ConsoleLogger(level: .debug)
            }
        case .staging:
            factory.addDependency(Logger.self) {
                FileLogger(level: .info)
            }
        case .production:
            factory.addDependency(Logger.self) {
                ProductionLogger(level: .warning)
            }
        }

        // í™˜ê²½ë³„ Analytics
        factory.addDependency(AnalyticsService.self) {
            switch environment {
            case .development:
                return MockAnalyticsService()
            case .staging, .production:
                return FirebaseAnalyticsService()
            }
        }

        return factory
    }
}

// ì‚¬ìš©ë²•
let environment = AppEnvironment.current
var factoryManager = ModuleFactoryManager()
factoryManager.diFactory = EnvironmentDiFactory.create(for: environment)
```

### ì•± ì‹œì‘ì‹œ ìë™ ì„¤ì •

`AppDIManager`ëŠ” v3.3.4ë¶€í„° ìë™ìœ¼ë¡œ `DiModuleFactory`ë¥¼ ì§€ì›í•©ë‹ˆë‹¤:

```swift
// AppDelegate ë˜ëŠ” App.swiftì—ì„œ
@main
struct MyApp: App {
    init() {
        setupDependencies()
    }

    private func setupDependencies() {
        // DiModuleFactoryëŠ” ìë™ìœ¼ë¡œ ë“±ë¡ë©ë‹ˆë‹¤
        // ModuleFactoryManagerë„ ìë™ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤

        // í•„ìš”í•œ ê²½ìš° ì¶”ê°€ ì„¤ì •
        let factoryManager = WeaveDI.Container.live.resolve(ModuleFactoryManager.self)

        factoryManager?.diFactory.addDependency(CustomService.self) {
            CustomServiceImpl()
        }
    }
}
```

### ê³ ê¸‰ íŒ¨í„´

#### ì¡°ê±´ë¶€ ì˜ì¡´ì„± ë“±ë¡

```swift
var factory = DiModuleFactory()

// ê¸°ëŠ¥ í”Œë˜ê·¸ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë“±ë¡
if FeatureFlags.isAnalyticsEnabled {
    factory.addDependency(AnalyticsService.self) {
        FirebaseAnalyticsService()
    }
} else {
    factory.addDependency(AnalyticsService.self) {
        NoOpAnalyticsService()
    }
}

// í”Œë«í¼ë³„ ì˜ì¡´ì„±
#if os(iOS)
factory.addDependency(BiometricService.self) {
    iOSBiometricService()
}
#elseif os(macOS)
factory.addDependency(BiometricService.self) {
    MacBiometricService()
}
#endif
```

#### ì˜ì¡´ì„± ì²´ì¸

```swift
var factory = DiModuleFactory()

// ì˜ì¡´ì„± ì²´ì¸ ì„¤ì •
factory.addDependency(NetworkClient.self) {
    let config = WeaveDI.Container.live.resolve(NetworkConfig.self)!
    let logger = WeaveDI.Container.live.resolve(Logger.self)!
    return NetworkClient(config: config, logger: logger)
}

factory.addDependency(APIService.self) {
    let client = WeaveDI.Container.live.resolve(NetworkClient.self)!
    return APIService(client: client)
}
```

### í…ŒìŠ¤íŒ… ì§€ì›

í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œ ì‰½ê²Œ ëª© ê°ì²´ë¡œ êµì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```swift
#if DEBUG
struct TestDiFactory {
    static func createMockFactory() -> DiModuleFactory {
        var factory = DiModuleFactory()

        factory.addDependency(Logger.self) {
            MockLogger()
        }

        factory.addDependency(NetworkClient.self) {
            MockNetworkClient()
        }

        factory.addDependency(AnalyticsService.self) {
            MockAnalyticsService()
        }

        return factory
    }
}

// í…ŒìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©
class SomeTestCase: XCTestCase {
    override func setUp() {
        super.setUp()

        var factoryManager = ModuleFactoryManager()
        factoryManager.diFactory = TestDiFactory.createMockFactory()

        await factoryManager.registerAllModules()
    }
}
#endif
```

### ëª¨ë²” ì‚¬ë¡€

1. **ì˜ì¡´ì„± ê·¸ë£¹í™”**: ê´€ë ¨ëœ ì˜ì¡´ì„±ë“¤ì„ í•¨ê»˜ ì„¤ì •
2. **í™˜ê²½ë³„ ë¶„ë¦¬**: ê°œë°œ/ìŠ¤í…Œì´ì§•/í”„ë¡œë•ì…˜ í™˜ê²½ë³„ë¡œ ë‹¤ë¥¸ êµ¬í˜„ì²´ ì‚¬ìš©
3. **ëŠ¦ì€ ë°”ì¸ë”©**: ì„¤ì • ë¡œë“œ í›„ ì˜ì¡´ì„± ë“±ë¡
4. **íƒ€ì… ì•ˆì „ì„±**: ì»´íŒŒì¼ íƒ€ì„ì— ì˜ëª»ëœ íƒ€ì… ë“±ë¡ ë°©ì§€
5. **í…ŒìŠ¤íŠ¸ ê²©ë¦¬**: í…ŒìŠ¤íŠ¸ìš© ì˜ì¡´ì„±ì„ ë³„ë„ë¡œ ê´€ë¦¬

`DiModuleFactory`ë¥¼ í†µí•´ ì•±ì˜ ê³µí†µ ì˜ì¡´ì„±ì„ ì²´ê³„ì ì´ê³  íƒ€ì… ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•  ìˆ˜ ìˆìœ¼ë©°, ë¹Œë” íŒ¨í„´ì„ í†µí•´ ì§ê´€ì ì´ê³  ì½ê¸° ì‰¬ìš´ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.